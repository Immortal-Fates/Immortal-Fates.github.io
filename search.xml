<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/27/Hello-World/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>仅以此blog记录生活点滴</p>
<p>优化进行ing</p>
<ul>
<li>以PicGo作为图床上传工具，在github上创建figure bed并连接typora（一键式typora插入图片自动上传并转化为url）</li>
</ul>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>记录搭建blog过程中遇到的一些东西</p>
<ul>
<li><p>github.io是静态网页每次修改都需要重新部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在/blog/source/_posts 中添加文件，然后再bash中重新部署</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">###本地查看</span><br><span class="line">hexo s</span><br><span class="line">###新建文章</span><br><span class="line">hexo n &#x27;filename&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置文章的tags and categories</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">	- life</span><br><span class="line">categories: life</span><br><span class="line">---</span><br><span class="line">### 以下是正文</span><br></pre></td></tr></table></figure>


</li>
<li><p>CDN(Content Delivery Network，内容分发网络)是一项非常有效的<strong>缩短时延</strong>的技术，采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求</p>
</li>
<li><p>YAML(.yml文件)，一种数据序列化格式，方便传输和存储</p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p>跟随知乎枫叶大佬<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a>搭建此blog</p>
</li>
<li><p><a href="https://github.com/jackfrued/Python-100-Days/blob/master/%E7%95%AA%E5%A4%96%E7%AF%87/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.md">Python-100-Days&#x2F;番外篇&#x2F;使用Hexo搭建自己的博客.md at master · jackfrued&#x2F;Python-100-Days (github.com)</a></p>
</li>
<li><p>Next主题设置：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/README.md">hexo-theme-next&#x2F;README.md at master · theme-next&#x2F;hexo-theme-next (github.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/433176170">两分钟带你了解YAML（.yml后缀文件） - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://news.netshop168.com/article-85934.html">rss订阅是什么意思?为什么要使用RSS?RSS也称为RSS订阅或RSS提要 (netshop168.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/347342082">如何利用 Github 搭建自己的免费图床？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎 (zhihu.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门</title>
    <url>/2023/08/05/Git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>following <a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a>来学习git的相关知识</p>
<p>希望通过<a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a>+<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>来进一步掌握Git</p>
<p><strong>Learn to love the command line. Leave the IDE behind.</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Version-control-Git"><a href="#Version-control-Git" class="headerlink" title="Version control(Git)"></a>Version control(Git)</h1><p>版本控制系统version control system(VCS)是一类用于追踪源代码（或其他文件、文件夹）改动的工具</p>
<h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><ul>
<li>这些工具可以帮助我们管理代码的修改历史</li>
<li>可以让协作编码变得更方便</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Immortal-Fates/figure_Bed@main/blog/git.png" alt="git"></p>
<h1 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h1><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h4 id="快照（snapshots）"><a href="#快照（snapshots）" class="headerlink" title="快照（snapshots）"></a>快照（snapshots）</h4><p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure>

<p>这个顶层的树包含了两个元素，一个名为 “foo” 的tree（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h4 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h4><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。</p>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图(directed acyclic graph (DAG))。有向无环图，这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。</p>
<blockquote>
<p>notes：快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
</blockquote>
<p>在 Git 中，这些快照被称为“提交commit”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>

<p>其中的 <code>o</code> 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>

<p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h4 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h4><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种简洁的历史模型。</p>
<h4 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h4><p>Git 中的对象可以是 blob、tree or commit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure>

<p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure>

<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，上面例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure>

<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code> (树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure>

<h4 id="引用-References"><a href="#引用-References" class="headerlink" title="引用(References)"></a>引用(References)</h4><p>Git 给这些哈希值赋予人类可读的名字，也就是引用（references）。<strong>引用是指向提交的指针</strong>。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></table></figure>

<p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h4 id="仓库-Repositories"><a href="#仓库-Repositories" class="headerlink" title="仓库(Repositories)"></a>仓库(Repositories)</h4><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当你输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h1 id="staging-area"><a href="#staging-area" class="headerlink" title="staging area"></a>staging area</h1><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h1 id="Git-的命令行接口"><a href="#Git-的命令行接口" class="headerlink" title="Git 的命令行接口"></a>Git 的命令行接口</h1><p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>或可以观看本讲座的视频来学习。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><p><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</p>
</li>
<li><p><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</p>
</li>
<li><p><code>git status</code>: 显示当前的仓库状态</p>
</li>
<li><p><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</p>
</li>
<li><pre><code class="plaintext">git commit
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  : 创建一个新的提交</span><br><span class="line"></span><br><span class="line">  - 如何编写 [良好的提交信息](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)!</span><br><span class="line">  - 为何要 [编写良好的提交信息](https://chris.beams.io/posts/git-commit/)</span><br><span class="line"></span><br><span class="line">- `git log`: 显示历史日志</span><br><span class="line"></span><br><span class="line">- `git log --all --graph --decorate`: 可视化历史记录（有向无环图）</span><br><span class="line"></span><br><span class="line">- `git diff &lt;filename&gt;`: 显示与暂存区文件的差异</span><br><span class="line"></span><br><span class="line">- `git diff &lt;revision&gt; &lt;filename&gt;`: 显示某个文件两个版本之间的差异</span><br><span class="line"></span><br><span class="line">- `git checkout &lt;revision&gt;`: 更新 HEAD 和目前的分支</span><br><span class="line"></span><br><span class="line">#### 分支和合并</span><br><span class="line"></span><br><span class="line">- `git branch`: 显示分支</span><br><span class="line"></span><br><span class="line">- `git branch &lt;name&gt;`: 创建分支</span><br><span class="line"></span><br><span class="line">- ```plaintext</span><br><span class="line">  git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure>

: 创建分支并切换到该分支

- 相当于 `git branch &lt;name&gt;; git checkout &lt;name&gt;`
</code></pre>
</li>
<li><p><code>git merge &lt;revision&gt;</code>: 合并到当前分支</p>
</li>
<li><p><code>git mergetool</code>: 使用工具来处理合并冲突</p>
</li>
<li><p><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</p>
</li>
</ul>
<h4 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h4><ul>
<li><code>git remote</code>: 列出远端</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li>
<li><code>git fetch</code>: 从远端获取对象&#x2F;索引</li>
<li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li>
<li><code>git clone</code>: 从远端下载仓库</li>
</ul>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul>
<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>
<li><code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li>
</ul>
<h1 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h1><ul>
<li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li>
<li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li>
<li><code>git add -p</code>: 交互式暂存</li>
<li><code>git rebase -i</code>: 交互式变基</li>
<li><code>git blame</code>: 查看最后修改某行的人</li>
<li><code>git stash</code>: 暂时移除工作目录下的修改内容</li>
<li><code>git bisect</code>: 通过二分查找搜索历史记录</li>
<li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li>
</ul>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><ul>
<li><p><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</p>
</li>
<li><p><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</p>
</li>
<li><p><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</p>
</li>
<li><p><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</p>
</li>
<li><p><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</p>
</li>
<li><p><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</p>
</li>
<li><p>良好的git提交消息(设置用于git的编辑器)</p>
<ul>
<li><p><a href="https://cbea.ms/git-commit/#separate">用空行将主题与正文分开</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline #只打印出主题行</span><br><span class="line">git shortlog #按用户提交哪些组，再次仅显示主题行以简洁明了</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://cbea.ms/git-commit/#limit-50">将主题行限制为 50 个字符</a>（make sure less than 72 characters）</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#capitalize">将主题行大写</a></p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#end">不要以句点结束主题行</a></p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#imperative">在主题行中使用命令式语气</a>:祈使句</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#wrap-72">将正文包装为 72 个字符</a>：It&#96;s easy to configure Vim</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#why-not-how">使用正文来解释什么和为什么与如何</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> ，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> ，简短的介绍了如何从 Git 错误中恢复；</li>
<li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li>
<li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a></li>
<li><a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">tbaggery - A Note About Git Commit Messages</a></li>
<li><a href="https://cbea.ms/git-commit/">How to Write a Git Commit Message (cbea.ms)</a></li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>-Git -CS</tag>
      </tags>
  </entry>
  <entry>
    <title>各种通信方式</title>
    <url>/2023/07/29/%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>了解及总结（同步通信-异步通信-全双工通信-串行通信-并行通信）各种通信方法</p>
<h1 id="并行通信-and-串行通信"><a href="#并行通信-and-串行通信" class="headerlink" title="并行通信 and 串行通信"></a>并行通信 and 串行通信</h1><h2 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h2><p>Parallel communication</p>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><p>多个数据bit位同时传输</p>
<h4 id="常用总线"><a href="#常用总线" class="headerlink" title="常用总线"></a>常用总线</h4><p>local bus,  DDR</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>同时传输，效率高</li>
<li>数据线多，设计复杂</li>
</ul>
<h2 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h2><p>Serial communication </p>
<h4 id="传输方式-1"><a href="#传输方式-1" class="headerlink" title="传输方式"></a>传输方式</h4><p>数据bit一位一位传输</p>
<h4 id="常用总线-1"><a href="#常用总线-1" class="headerlink" title="常用总线"></a>常用总线</h4><p>local bus,  DDR</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>按bit逐位传输，效率低</li>
<li>只需一根数据线，设计简单</li>
</ul>
<h1 id="异步串行通信-and-同步串行通信"><a href="#异步串行通信-and-同步串行通信" class="headerlink" title="异步串行通信 and 同步串行通信"></a>异步串行通信 and 同步串行通信</h1><h2 id="异步串行通信"><a href="#异步串行通信" class="headerlink" title="异步串行通信"></a>异步串行通信</h2><p>Asynchronous serial communication</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息发送设备与接收设备之间无时钟连接</li>
<li>信息中包含特殊标志位Start&#x2F;Stop</li>
<li>接收设备根据特殊标志位利用本地时钟对数据采样</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>UART，无时钟线连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收器   发送器</span><br><span class="line">TxD-----&gt;RxD</span><br><span class="line">RxD&lt;-----TxD</span><br></pre></td></tr></table></figure>



<h2 id="同步串行通信"><a href="#同步串行通信" class="headerlink" title="同步串行通信"></a>同步串行通信</h2><p>Synchronous serial communciation</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息发送设备与接收设备需要时钟同步</li>
<li>两者间出数据线连接，还需要额外的时钟线连接</li>
</ul>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>IIC,需要时钟线SCL连接</p>
<h1 id="三种数据通路：单工，半双工，全双工"><a href="#三种数据通路：单工，半双工，全双工" class="headerlink" title="三种数据通路：单工，半双工，全双工"></a>三种数据通路：单工，半双工，全双工</h1><h2 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h2><p>Simplex communciation</p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息只能单一方向传输</li>
</ul>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><p>广播，遥控器</p>
<h2 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h2><p>Half-duplex communciation</p>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数据支持双向传输</li>
<li>发送和接收不能同时进行，同一时间只能发送or接收数据</li>
</ul>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><p>IIC</p>
<h2 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h2><p>Full-duplex communciation</p>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数据支持双向传输</li>
<li>数据接收和发送同时进行</li>
</ul>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><p>电话、网口、UART</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>B站视频：【四分钟搞定【同步通信-异步通信-全双工通信-串行通信-并行通信】】<a href="https://www.bilibili.com/video/BV1q64y1R72M?vd_source=93bb338120537438ee9180881deab9c1">https://www.bilibili.com/video/BV1q64y1R72M?vd_source=93bb338120537438ee9180881deab9c1</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>-嵌入式 -通信</tag>
      </tags>
  </entry>
  <entry>
    <title>基于cubeMX创建的第一个stm32工程</title>
    <url>/2023/08/04/%E5%9F%BA%E4%BA%8EcubeMX%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAstm32%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基于STM32Cube框架的第一个stm32程序从新建到编译上传"><a href="#基于STM32Cube框架的第一个stm32程序从新建到编译上传" class="headerlink" title="基于STM32Cube框架的第一个stm32程序从新建到编译上传"></a>基于STM32Cube框架的第一个stm32程序从新建到编译上传</h1><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><ul>
<li>通过STM32CubeMX选择芯片、配置外设，并生成代码</li>
<li>在选用的编辑器中编辑代码，编写程序</li>
<li>编译代码，生成二进制文件并上传</li>
<li>调试代码的运行效果</li>
</ul>
<h2 id="芯片配置"><a href="#芯片配置" class="headerlink" title="芯片配置"></a>芯片配置</h2><h3 id="选择芯片-开发板"><a href="#选择芯片-开发板" class="headerlink" title="选择芯片&#x2F;开发板"></a>选择芯片&#x2F;开发板</h3><p>但是需要注意，若选择官方开发板作为硬件，则会提供“按照开发板上的电路及布局默认配置硬件”的选项</p>
<h3 id="配置内核与外设硬件"><a href="#配置内核与外设硬件" class="headerlink" title="配置内核与外设硬件"></a>配置内核与外设硬件</h3><p><strong>系统配置</strong>：时钟配置+调试配置</p>
<p><strong>时钟配置</strong>（必要）：STM32有四个时钟源：LSI（低速内部时钟）、LSE（低速外部时钟）、HIS（高速内部时钟）和HSE（高速外部时钟）；有的型号仅有其中某几个。默认的配置是采用芯片内部自带的振荡器、主频配置为8MHz。Nucleo F103RB中芯片外接了8MHz的晶振，故将“HSE”项配置为“Crystal&#x2F;Ceramic Resonator”，这就是说使用高速外部时钟，且时钟源为晶振。具体频率则在时钟树界面中配置（在使用内部振荡器时F1系列芯片最高主频是64MHz，在使用8MHz外部晶振时最高主频是72MHz。）</p>
<p><img src="https://github.com/Immortal-Fates/Immortal-Fates.github.io/blob/master/photos/image-20230605232417189.png" alt="image-20230605232417189"></p>
<p><strong>调试配置</strong>：用于配置调试的类型（如果芯片未被配置为调试模式就强行对其进行调试，则会造成芯片内部启动程序错误而导致之后无法正常烧录程序，此时需擦除其Flash以修复）</p>
<p>主流的调试方式有SWD和JTAG两种，而SWD是更方便的方法。若要使用SWD进行调试，则必须将芯片配置为“Serial Wire”调试。</p>
<p><strong>外设硬件</strong>：芯片中的所有外设都可以在软件中配置，包括DMA、ADC、定时器等</p>
<h3 id="配置工程，生成代码"><a href="#配置工程，生成代码" class="headerlink" title="配置工程，生成代码"></a>配置工程，生成代码</h3><h4 id="工程名称，路径"><a href="#工程名称，路径" class="headerlink" title="工程名称，路径"></a>工程名称，路径</h4><h4 id="应用结构："><a href="#应用结构：" class="headerlink" title="应用结构："></a><strong>应用结构</strong>：</h4><p>应用结构有“Basic”和“Advanced”两个选项。如果观察仔细的话，会发现STM32CubeIDE工程中的CubeMX项目默认的是“Advanced”结构，而单独使用CubeMX默认的是“Basic”结构</p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://github.com/Immortal-Fates/Immortal-Fates.github.io/blob/master/photos/image-20230605232846792.png" alt="image-20230605232846792"></h6><h4 id="工具链-IDE："><a href="#工具链-IDE：" class="headerlink" title="工具链&#x2F;IDE："></a>工具链&#x2F;IDE：</h4><p>STM32CubeMX除了配置硬件外，还提供了直接生成工程		的功能，即由该“工具链&#x2F;IDE”选项确定。STM32CubeMX预先包含了7种		开发方式，分别是：EWARM、MDK-ARM、SW4STM32、TrueStudio、		STM32CubeIDE、Makefile和Other Toolchains(GPDSC)</p>
<p>****MDK-ARM****：Keil uVision采用的开发环境，使用此选项可以直接生成Keil完整工程。</p>
<p>****TrueStudio、STM32CubeIDE****：TrueStudio是STM32CubeIDE的前身。TrueStudio本身是以Eclipse为基础配置而成的STM32开发工具，在被ST收购被ST与STM32CubeMX合并，形成了STM32CubeIDE。故该两种选项生成的项目并无较大区别。对于使用Eclipse自行配置来为STM32开发的同学，也可以选择该选项。</p>
<p>****Makefile****：Makefile实际上是“make”这个程序为了实现自动化构建工程而读取的一种文件。make从Makefile文件中读取生成的对象、编译的顺序、文件的依赖等信息，然后使用gcc或者g++来编译。Makefile不仅适用于系统下的标准C&#x2F;C++工程，也适用于嵌入式开发。为Arm架构芯片开发的gcc叫做“arm-none-eabi-gcc”，可以在GNU的官网上下载。PlatformIO使用gcc来编译STM32的程序，故采用Makefile选项更搭配。</p>
<p>但实际上PlatformIO自带一套使用Python来构建工程的方法，因此用不到Makefile；真正需要的只是“Inc”和“Src”两个文件夹中的代码而已。如果有同学有兴趣的话，可以尝试使用gcc搭配make自行搭建一套工具链，这个时候STM32CubeMX生成的Makefile文件就会派上用场。</p>
<h4 id="包管理："><a href="#包管理：" class="headerlink" title="包管理："></a>包管理：</h4><p>包管理有三种选项，翻译过来就是：仅复制用到的库文件、复制所有库文件、仅添加引用。</p>
<p>​	<img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605232417189.png" alt="image-20230605232417189"></p>
<p>当选择了复制库文件到工程时，除了Inc和Src两个文件夹（或Advanced模式下的Core文件夹）外，还会额外生成一个Driver文件夹，其中放置的便是STM32的库文件。当启用了USB或者FreeRTOS等中间件后，也还会额外生成一个Middleware文件夹，其中放置的便是中间件的库文件。文件结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605232846792.png" alt="image-20230605232846792"></p>
<h4 id="生成选项："><a href="#生成选项：" class="headerlink" title="生成选项："></a>生成选项：</h4><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605233713820.png" alt="image-20230605233713820"></p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>&#x2F;* USER CODE BEGIN x *&#x2F; *</p>
<p> &#x2F;* USER CODE END x *&#x2F;</p>
<p>其中的x可以是数字，也可以是别的一些标识符。STM32CubeMX希望用户将自己的代码插入到“BEGIN”和“END”当中，</p>
<p><strong>reason:</strong></p>
<p>之所以要这样做是因为STM32CubeMX在更新代码时不会修改这两句注释之间的内容。比如当用户的需求发生了变动，需要修改硬件配置时，就需要使用STM32CubeMX来修改并重新生成代码。如果将用户代码放在这两句注释之间，STM32CubeMX就不会在重新生成代码的时候覆盖掉这部分。这使得硬件配置的更改变得更加方便</p>
<h2 id="编译上传"><a href="#编译上传" class="headerlink" title="编译上传"></a>编译上传</h2><p>单片机、乃至目前一切电脑都不能直接运行代码文件，必须通过编译器将代码文件编译成CPU能够处理的机器语言——即二进制机器指令——才能烧录到芯片执行。STM32主流的编译器——也即arm芯片所用的编译器——有两种：arm-gcc和Arm Compiler。Keil默认采用Arm Compiler，而STM32CubeIDE和PlatformIO则采用arm-gcc。二者在编译原理上有差别，但是在代码层面很难体现出来</p>
<h2 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h2><p>ST-Link不只是程序下载器，还是调试器，能够通过JTAG接口或者SWD接口控制芯片的运行、读取芯片的寄存器、内存等。我们可以观察到芯片中每个寄存器的值、每个变量的值及其变化，可以通过断点让程序运行到指定的位置、检测中断的执行；从而能够方便地调试代码。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>STM32CubeMX软件生成出来的代码具有高度的结构性。按文件予以区分，各个文件的功能如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>stm32f1xx_it.h&#x2F;stm32f1xx_it.c</td>
<td>实现stm32的所有中断程序</td>
</tr>
<tr>
<td>stm32f1xx_hal_conf.h</td>
<td>HAL库配置文件</td>
</tr>
<tr>
<td>system_stm32f1xx.c</td>
<td>在内核层面上设置系统时钟</td>
</tr>
<tr>
<td>stm32f1xx_hal_msp.c</td>
<td>特定单片机具体配置</td>
</tr>
<tr>
<td>main.h</td>
<td>包含了应用程序全局的定义</td>
</tr>
<tr>
<td>main.c</td>
<td>实现主程序</td>
</tr>
<tr>
<td>gpio.h&#x2F;gpio.c（以及类似的tim、usart等）</td>
<td>专门配置某个外设硬件</td>
</tr>
</tbody></table>
<p>接下来将逐个讲解这些文件的功能。</p>
<h3 id="文件与程序功能"><a href="#文件与程序功能" class="headerlink" title="文件与程序功能"></a>文件与程序功能</h3><h4 id="stm32f1xx-hal-conf-h："><a href="#stm32f1xx-hal-conf-h：" class="headerlink" title="stm32f1xx_hal_conf.h："></a>stm32f1xx_hal_conf.h：</h4><p>该文件定义了启用的HAL模块，并设置了一些宏参数——比如晶振频率等。此处仅仅介绍模块启用的相关代码。</p>
<p>C&#x2F;C++中的宏常用于选择性编译的程序，此处即使用了此原理。通过一系列宏来确定需要引用哪些头文件</p>
<p>只有定义了对应的宏，才会引用对应的头文件，对应的模块才能够在应用中使用。这些宏不需要使用者手动定义，STM32CubeMX会自动根据在软件中选择的配置来定义这些宏、启用对应的模块。</p>
<h4 id="system-stm32f1xx-c"><a href="#system-stm32f1xx-c" class="headerlink" title="system_stm32f1xx.c"></a>system_stm32f1xx.c</h4><p>该文件不涉及任何HAL库中的内容，仅仅从内核上使用寄存器的方式来初始化时钟，并提供了时钟频率值更新的函数。该文件中包含两个函数，如下所示：</p>
<table>
<thead>
<tr>
<th>SystemInit()</th>
<th>按照默认配置设置系统时钟、嵌入式Flash等</th>
</tr>
</thead>
<tbody><tr>
<td>SystemCoreClockUpdate()</td>
<td>根据当前的配置计算芯片主频</td>
</tr>
</tbody></table>
<p>这两个函数在代码中都没有显式调用。实际上SystemInit()的调用是写在启动文件中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Call the clock system intitialization function.*/  </span><br><span class="line">bl  SystemInit</span><br></pre></td></tr></table></figure>

<p>其调用发生在复位后、进入主函数前。其实本来可以通过修改该函数的参数就能实现时钟树的配置，但是HAL库选择了以自己的方法实现时钟配置，因此SystemInit()函数仅仅实现了默认的时钟配置，也就是采用内部时钟、主频为8MHz。真正的时钟配置是在主函数中进行的。</p>
<h4 id="stm32f1xx-it-h-stm32f1xx-it-c"><a href="#stm32f1xx-it-h-stm32f1xx-it-c" class="headerlink" title="stm32f1xx_it.h&#x2F;stm32f1xx_it.c"></a>stm32f1xx_it.h&#x2F;stm32f1xx_it.c</h4><p>这两个文件包含了单片机用到的所有中断服务程序，主要分为两个部分：内核中断和外设中断。</p>
<h5 id="内核中断"><a href="#内核中断" class="headerlink" title="内核中断"></a>内核中断</h5><p>在代码中内核中断以以下注释作为开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**********************************************************************/ /*    Cortex-M3 Processor Interruption and Exception Handlers     */  /**********************************************************************/</span><br></pre></td></tr></table></figure>

<p>内核中断指的是那些由STM32芯片中内核部分——包括F1系列采用的Cortex-M3内核、F4系列采用的Cortex-M4内核等——产生的中断。这些中断多是一些通用的、系统性的中断，如SysTick_Handler（系统滴答定时器中断）、HardFault_Handler（硬件错误中断）等。STM32CubeMX将其自动列出来，方便使用者修改。比如HardFault_Handler，当系统出现硬件错误的时候便会跳转到这里，可以利用这一中断函数很快定位bug的来源。</p>
<p>注意，内核中断中的SysTick_Handler默认被HAL库用于计时。如果没有实现该中断函数则会使HAL库失去计时功能。当然这也是已经由STM32CubeMX软件自动完成了，可以在SysTick_Handler函数中看见被调用的库函数HAL_IncTick。</p>
<p> 系统滴答定时器中断：由系统滴答定时器产生</p>
<p> 硬件错误中断：当发生内存溢出、访问越界、堆栈溢出时进入</p>
<p> HAL库计时功能默认采用系统滴答定时器来进行计时，但也可以换用TIM1、TIM2等外设计时器：可在STM32CubeMX的SYS部分配置</p>
<h5 id="外设中断"><a href="#外设中断" class="headerlink" title="外设中断"></a>外设中断</h5><p>在代码中外设中断以以下注释作为开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**********************************************************************/ /* STM32F1xx Peripheral Interrupt Handlers                 */ /* Add here the Interrupt Handlers for the used peripherals.      */ /* For the available peripheral interrupt handler names,         */ /* please refer to the startup file (startup_stm32f1xx.s).        */ /**********************************************************************/</span><br></pre></td></tr></table></figure>

<p>外设中断指的是由单片机内非内核部分的外设硬件产生的中断，如定时器中断、外部中断、串口中断等。当在STM32CubeMX中选择了相应的中断时便会自动在此处添加中断服务函数。</p>
<h4 id="stm32f1xx-hal-msp-c"><a href="#stm32f1xx-hal-msp-c" class="headerlink" title="stm32f1xx_hal_msp.c"></a>stm32f1xx_hal_msp.c</h4><p>MSP指的是MCU Specific Package，即单片机具体方案。HAL库体系下，初始化分为两个步骤：抽象层初始化和MSP初始化。</p>
<p>以串口为例。串口的属性包括波特率、数据位、校验位等；但是这些属性属于抽象属性，无论这个串口是STM32单片机的串口1还是串口2，或者是Arduino上的甚至51单片机上的串口，都拥有这些属性。抽象属性的初始化即为抽象层的初始化。但是要让串口真正工作起来，仅仅告诉它波特率多少、数据位多少、有无校验位是不够的，还要配置串口的时钟、串口的DMA、串口的复用引脚等，而这些属性在不同单片机上是不一样的。这些初始化即为MSP初始化。只有经过了这两层初始化，开发者才能按照需求使用抽象硬件。</p>
<p>该文件实现的即是单片机全局的MSP初始化函数：HAL_MspInit()。如下所示，实现了复用引脚和电源的时钟使能，并且关闭了JTAG调试而改用SWD调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> \* Initializes the Global MSP.</span><br><span class="line"> */</span><br><span class="line">void HAL_MspInit(void)</span><br><span class="line">&#123;</span><br><span class="line"> __HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line"> __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line"> /* System interrupt init*/</span><br><span class="line"></span><br><span class="line"> /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled</span><br><span class="line"> */</span><br><span class="line"> __HAL_AFIO_REMAP_SWJ_NOJTAG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数并非在源文件中进行调用，而是在库文件中进行调用。HAL库的初始化函数在进行完毕抽象层的初始化后便会调用相应的MSP初始化函数。</p>
<h4 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h4><p>该文件包含了全局的宏定义，并且包含了单片机的库文件。从STM32Cube的设计上来看，官方希望开发者将全局的定义、包含、常量等都写在该文件中，并在各个源文件中都包含该main.h</p>
<p>文件中为开发者预留了填写包含（Private includes）、类型（Exported types）、常量（Exported constants）、宏函数（Exported macro）、函数原型（Exported functions prototypes）和宏定义（Private defines）。用户可将自己的代码填写在“USER CODE BEGIN”和“USER CODE END”之间。</p>
<p>Tips:</p>
<p>由于用户可能多次使用STM32CubeMX进行代码生成，故代码文件中的内容会被多次重写。如果要修改生成的源文件，请务必将代码填写在“USER CODE BEGIN”和“USER CODE END”之间，因为STM32CubeMX在重新生成代码时会识别该标志并保留其中的用户代码。</p>
<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><p>在main函数中，首先初始化了HAL库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">HAL_Init();</span><br></pre></td></tr></table></figure>

<p>然后配置了系统时钟。此处的时钟配置和之前的SystemInit函数不一样，SystemInit函数中直接修改寄存器配置时钟，而此处则使用HAL库的库函数来配置；该函数也在main.c文件中实现，将单片机的时钟配置成软件中时钟树所配置成的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Configure the system clock */ SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>其次初始化了所有外设。本例中仅有GPIO进行了初始化，因此此处也仅有GPIO的初始化函数。以后若有其他外设需要初始化，CubeMX也会将其放在该位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialize all configured peripherals */ MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>接下来便进入死循环。单片机上的程序不像我们电脑上的程序；电脑上的程序运行结束后就由操作系统回收资源了，单片机上的程序则会一直运行，从主函数返回后就回到了汇编启动文件中，接下来单片机的行为就不是我们在C语言代码中可以控制的了。因此在main函数中写入一个死循环，程序就不会从main函数退出。而实际的应用场景中，我们需要实现的功能很多时候也正是需要写在死循环中不断去执行，本例中的LED灯闪烁。</p>
<h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>stm32的工程为C语言工程，编译时不会产生元数据，全靠头文件的包含和源文件的编译链接来实现工程组成，因此尤其需要开发者设计好合适的工程结构。</p>
<p>关于C语言工程的结构，网上有许多的文章都提供了如何组织代码的方法。实际上代码的组织并没有一个非常统一的方案，大多都是按照开发者自己的喜好来设计。此处也不会要求同学们使用某种代码组织方法，仅仅提供笔者使用的代码结构供参考。</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131555059.png" alt="image-20230606131555059"></p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131609394.png" alt="image-20230606131609394"></p>
<p>当程序的逻辑逐渐复杂的时候，也可以不仅仅使用一对App.h&#x2F;c文件来实现全部逻辑，而可以使用多个文件分别实现一部分，此处不详述。</p>
<h4 id="一些别的原则"><a href="#一些别的原则" class="headerlink" title="一些别的原则"></a>一些别的原则</h4><ul>
<li><p>不要包含源文件，而是包含头文件；头文件中也不要包含函数或者全局变量的定义，而仅仅包含其声明。将函数的定义放在源文件里，函数的声明放在头文件中；变量的定义放在源文件里，再在头文件中将其extern</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131804276.png" alt="image-20230606131804276"></p>
</li>
<li><p>使用易理解函数、类型、变量名称。杜绝使用意义不明的命名，如a、b、l、m等，而要使用意义明确的名字，如使用单词或者易于理解的缩写来描述。此处不推荐使用拼音进行命名。如下展示的是STM32的HAL库中的一个函数命名作为示例</p>
<table>
<thead>
<tr>
<th><em><strong>*函数名：HAL_GPIO_WritePin*</strong></em></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*HAL*</strong></em></td>
<td><em><strong>*GPIO*</strong></em></td>
<td><em><strong>*WritePin*</strong></em></td>
</tr>
<tr>
<td>该函数隶属于HAL库</td>
<td>该函数与GPIO相关</td>
<td>该函数的功能是写引脚的值</td>
</tr>
</tbody></table>
</li>
<li><p>使用规律的命名规则。常见的几种基础的命名规则如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>驼峰命名</th>
<th>组成变量名的第一个单词的首字母小写，其余的首字母大写。Arduino采用的便是驼峰命名规则，如analogWrite，attachInterrupt等。</th>
</tr>
</thead>
<tbody><tr>
<td>帕斯卡命名</td>
<td>组成变量名的各个单词的首字母均大写。C#就常用帕斯卡命名规则，如Console.WriteLine，XmlSerializer等。</td>
</tr>
<tr>
<td>下划线命名</td>
<td>组成变量名的单词均为小写，其间使用下划线连接。树莓派Pico的SDK采用的便是下划线命名，如hw_set_bits、sleep_ms</td>
</tr>
</tbody></table>
<p>这些命名规则仅仅作为参考，实际上可以使用混合的命名规则，比如公共成员使用帕斯卡命名、私有成员使用驼峰命名，或者在一个变量中使用组合式的命名规则。但是在整个工程中对象的命名规则务必有迹可循。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>-嵌入式 -robomaster</tag>
      </tags>
  </entry>
</search>
