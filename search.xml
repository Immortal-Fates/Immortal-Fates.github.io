<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git入门</title>
    <url>/2023/08/05/Git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>following <a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a>来学习git的相关知识</p>
<p>希望通过<a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a>+<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a>来进一步掌握Git</p>
<p><strong>Learn to love the command line. Leave the IDE behind.</strong></p>
<span id="more"></span>

<h1 id="Version-control-Git"><a href="#Version-control-Git" class="headerlink" title="Version control(Git)"></a>Version control(Git)</h1><p>版本控制系统version control system(VCS)是一类用于追踪源代码（或其他文件、文件夹）改动的工具</p>
<h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><ul>
<li>这些工具可以帮助我们管理代码的修改历史</li>
<li>可以让协作编码变得更方便</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>VCS通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Immortal-Fates/figure_Bed@main/blog/git.png" alt="git"></p>
<h1 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h1><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h4 id="快照（snapshots）"><a href="#快照（snapshots）" class="headerlink" title="快照（snapshots）"></a>快照（snapshots）</h4><p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure>

<p>这个顶层的树包含了两个元素，一个名为 “foo” 的tree（它本身包含了一个blob对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h4 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h4><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。</p>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图(directed acyclic graph (DAG))。有向无环图，这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。</p>
<blockquote>
<p>notes：快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
</blockquote>
<p>在 Git 中，这些快照被称为“提交commit”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>

<p>其中的 <code>o</code> 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>

<p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h4 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h4><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种简洁的历史模型。</p>
<h4 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h4><p>Git 中的对象可以是 blob、tree or commit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure>

<p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure>

<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，上面例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure>

<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt</code> (blob) 和 <code>foo</code> (树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz.txt 的内容，会得到以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure>

<h4 id="引用-References"><a href="#引用-References" class="headerlink" title="引用(References)"></a>引用(References)</h4><p>Git 给这些哈希值赋予人类可读的名字，也就是引用（references）。<strong>引用是指向提交的指针</strong>。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></table></figure>

<p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意， 通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h4 id="仓库-Repositories"><a href="#仓库-Repositories" class="headerlink" title="仓库(Repositories)"></a>仓库(Repositories)</h4><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当你输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h1 id="staging-area"><a href="#staging-area" class="headerlink" title="staging area"></a>staging area</h1><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照” 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h1 id="Git-的命令行接口"><a href="#Git-的命令行接口" class="headerlink" title="Git 的命令行接口"></a>Git 的命令行接口</h1><p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>或可以观看本讲座的视频来学习。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li><p><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</p>
</li>
<li><p><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</p>
</li>
<li><p><code>git status</code>: 显示当前的仓库状态</p>
</li>
<li><p><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</p>
</li>
<li><pre><code class="plaintext">git commit
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  : 创建一个新的提交</span><br><span class="line"></span><br><span class="line">  - 如何编写 [良好的提交信息](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)!</span><br><span class="line">  - 为何要 [编写良好的提交信息](https://chris.beams.io/posts/git-commit/)</span><br><span class="line"></span><br><span class="line">- `git log`: 显示历史日志</span><br><span class="line"></span><br><span class="line">- `git log --all --graph --decorate`: 可视化历史记录（有向无环图）</span><br><span class="line"></span><br><span class="line">- `git diff &lt;filename&gt;`: 显示与暂存区文件的差异</span><br><span class="line"></span><br><span class="line">- `git diff &lt;revision&gt; &lt;filename&gt;`: 显示某个文件两个版本之间的差异</span><br><span class="line"></span><br><span class="line">- `git checkout &lt;revision&gt;`: 更新 HEAD 和目前的分支</span><br><span class="line"></span><br><span class="line">#### 分支和合并</span><br><span class="line"></span><br><span class="line">- `git branch`: 显示分支</span><br><span class="line"></span><br><span class="line">- `git branch &lt;name&gt;`: 创建分支</span><br><span class="line"></span><br><span class="line">- ```plaintext</span><br><span class="line">  git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure>

: 创建分支并切换到该分支

- 相当于 `git branch &lt;name&gt;; git checkout &lt;name&gt;`
</code></pre>
</li>
<li><p><code>git merge &lt;revision&gt;</code>: 合并到当前分支</p>
</li>
<li><p><code>git mergetool</code>: 使用工具来处理合并冲突</p>
</li>
<li><p><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</p>
</li>
</ul>
<h4 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h4><ul>
<li><code>git remote</code>: 列出远端</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li>
<li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li>
<li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li>
<li><code>git fetch</code>: 从远端获取对象&#x2F;索引</li>
<li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li>
<li><code>git clone</code>: 从远端下载仓库</li>
</ul>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><ul>
<li><code>git commit --amend</code>: 编辑提交的内容或信息</li>
<li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li>
<li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li>
<li><code>git restore</code>: git2.32版本后取代git reset 进行许多撤销操作</li>
</ul>
<h1 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h1><ul>
<li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li>
<li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li>
<li><code>git add -p</code>: 交互式暂存</li>
<li><code>git rebase -i</code>: 交互式变基</li>
<li><code>git blame</code>: 查看最后修改某行的人</li>
<li><code>git stash</code>: 暂时移除工作目录下的修改内容</li>
<li><code>git bisect</code>: 通过二分查找搜索历史记录</li>
<li><code>.gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li>
</ul>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><ul>
<li><p><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</p>
</li>
<li><p><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>这样的框架中一般以及集成了这一功能</p>
</li>
<li><p><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</p>
</li>
<li><p><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 ( 有<a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</p>
</li>
<li><p><strong>GitHub</strong>: Git 并不等同于 GitHub。 在 GitHub 中您需要使用一个被称作<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a>的方法来向其他项目贡献代码</p>
</li>
<li><p><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</p>
</li>
<li><p>良好的git提交消息(设置用于git的编辑器)</p>
<ul>
<li><p><a href="https://cbea.ms/git-commit/#separate">用空行将主题与正文分开</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline #只打印出主题行</span><br><span class="line">git shortlog #按用户提交哪些组，再次仅显示主题行以简洁明了</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://cbea.ms/git-commit/#limit-50">将主题行限制为 50 个字符</a>（make sure less than 72 characters）</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#capitalize">将主题行大写</a></p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#end">不要以句点结束主题行</a></p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#imperative">在主题行中使用命令式语气</a>:祈使句</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#wrap-72">将正文包装为 72 个字符</a>：It&#96;s easy to configure Vim</p>
</li>
<li><p><a href="https://cbea.ms/git-commit/#why-not-how">使用正文来解释什么和为什么与如何</a></p>
</li>
</ul>
</li>
</ul>
<h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1><ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> ，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> ，简短的介绍了如何从 Git 错误中恢复；</li>
<li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li>
<li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://missing-semester-cn.github.io/2020/version-control/">版本控制(Git) · the missing semester of your cs education (missing-semester-cn.github.io)</a></li>
<li><a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">tbaggery - A Note About Git Commit Messages</a></li>
<li><a href="https://cbea.ms/git-commit/">How to Write a Git Commit Message (cbea.ms)</a></li>
<li><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/27/Hello-World/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>仅以此blog记录生活点滴</p>
<p>优化进行ing</p>
<ul>
<li>以PicGo作为图床上传工具，在github上创建figure bed并连接typora（一键式typora插入图片自动上传并转化为url）</li>
<li>增加search function</li>
<li>设置预览摘要</li>
<li>主页文章添加阴影效果</li>
<li>给一篇文章设置多标签</li>
</ul>
<span id="more"></span>

<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>记录搭建blog过程中遇到的一些东西</p>
<ul>
<li><p>github.io是静态网页每次修改都需要重新部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在/blog/source/_posts 中添加文件，然后再bash中重新部署</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">###本地查看</span><br><span class="line">hexo s</span><br><span class="line">###新建文章</span><br><span class="line">hexo n &#x27;filename&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置文章的tags and categories</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags: [ &#x27;标签1&#x27; , &#x27;标签2&#x27; , &#x27;标签3&#x27; ]  #注意空格</span><br><span class="line">categories: life</span><br><span class="line">---</span><br><span class="line">### 以下是正文</span><br></pre></td></tr></table></figure>


</li>
<li><p>CDN(Content Delivery Network，内容分发网络)是一项非常有效的<strong>缩短时延</strong>的技术，采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求</p>
</li>
<li><p>YAML(.yml文件)，一种数据序列化格式，方便传输和存储</p>
</li>
<li><p>只要我们在文章中插入 <!-- more -->，该标签之上的是摘要，之后的内容不可见，需点击全文阅读按钮。</p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p>跟随知乎枫叶大佬<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a>搭建此blog</p>
</li>
<li><p><a href="https://github.com/jackfrued/Python-100-Days/blob/master/%E7%95%AA%E5%A4%96%E7%AF%87/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.md">Python-100-Days&#x2F;番外篇&#x2F;使用Hexo搭建自己的博客.md at master · jackfrued&#x2F;Python-100-Days (github.com)</a></p>
</li>
<li><p>Next主题设置：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/README.md">hexo-theme-next&#x2F;README.md at master · theme-next&#x2F;hexo-theme-next (github.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/52362950">到底什么是CDN？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/433176170">两分钟带你了解YAML（.yml后缀文件） - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://news.netshop168.com/article-85934.html">rss订阅是什么意思?为什么要使用RSS?RSS也称为RSS订阅或RSS提要 (netshop168.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/347342082">如何利用 Github 搭建自己的免费图床？ - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN总线学习——底层逻辑</title>
    <url>/2023/08/08/CAN%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>记录学习CAN的历程，主要是CAN的底层逻辑。</p>
<p>highly comment直接看References中的文章，在此仅作回顾总结，并就其中一些内容进行修改和补充(见Tips和Bonus)。</p>
<p>感谢CAN总线学习笔记系列，让人受益匪浅。</p>
<p>下一步学习CAN上层应用主要书CAN过滤器和API的使用</p>
<span id="more"></span>

<h1 id="CAN基础知识"><a href="#CAN基础知识" class="headerlink" title="CAN基础知识"></a>CAN基础知识</h1><h3 id="CAN的一些基本概念"><a href="#CAN的一些基本概念" class="headerlink" title="CAN的一些基本概念"></a>CAN的一些基本概念</h3><p>CAN(controller area network)是串行通信协议；CAN总线就是一种传输数据的线</p>
<ul>
<li>高速CAN通信标准，闭环总线</li>
<li>低俗CAN通信标准，开环总线</li>
</ul>
<blockquote>
<p>Tips:总线传输速率：位速率or比特率</p>
</blockquote>
<h3 id="CAN的拓扑结构"><a href="#CAN的拓扑结构" class="headerlink" title="CAN的拓扑结构"></a>CAN的拓扑结构</h3><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807000301535.png" alt="image-20230807000301535"></p>
<h3 id="CAN信号表示"><a href="#CAN信号表示" class="headerlink" title="CAN信号表示"></a>CAN信号表示</h3><p>CAN总线上，利用CAN_H and CAN_L两根线的电位差来表示CAN信号，显性电平（逻辑0），隐性电平（逻辑1）</p>
<h3 id="CAN信号传输"><a href="#CAN信号传输" class="headerlink" title="CAN信号传输"></a>CAN信号传输</h3><ul>
<li>发送方是总线电平发生变化</li>
<li>接收方监听总线电平，读入自己的接收器</li>
</ul>
<h1 id="CAN通信的特点"><a href="#CAN通信的特点" class="headerlink" title="CAN通信的特点"></a>CAN通信的特点</h1><h3 id="多主工作方式"><a href="#多主工作方式" class="headerlink" title="多主工作方式"></a>多主工作方式</h3><p>结点无主从之分，只要总线空闲则均可发消息，最先发消息的结点获得总线的发送权（一起发则看优先权）</p>
<blockquote>
<p>Tips:&lt;总线空闲状态&gt;：连续的11位隐性电平（结合CAN协议的帧结构）</p>
</blockquote>
<h3 id="非破坏性位仲裁机制"><a href="#非破坏性位仲裁机制" class="headerlink" title="非破坏性位仲裁机制"></a>非破坏性位仲裁机制</h3><p>一起发消息的节点会进行逐位仲裁，不会造成已发送数据的延迟，也不会破坏已经发送的数据</p>
<h3 id="系统的柔性"><a href="#系统的柔性" class="headerlink" title="系统的柔性"></a>系统的柔性</h3><p>节点无“地址”概念，因此增加节点对已有节点的软硬件及应用层造成影响</p>
<h3 id="通信速度"><a href="#通信速度" class="headerlink" title="通信速度"></a>通信速度</h3><p>同一条CAN线，节点通信速度必须相同，如果两条不同通信速度总线上的节点想要实现信息交互，必须通过网关</p>
<blockquote>
<p>Tips:网关实质上是<strong>一个网络通向其他网络的IP地址</strong>。</p>
</blockquote>
<h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><p>可实现一对一，一对多以及广播的数据传输方式，依赖于验收滤波技术</p>
<h3 id="远程数据请求"><a href="#远程数据请求" class="headerlink" title="远程数据请求"></a>远程数据请求</h3><p>Node_A可以通过发送“遥控帧”到总线上来请求Node_B发送由该遥控帧所指定的报文</p>
<h3 id="错误检测、错误通知、错误恢复functions"><a href="#错误检测、错误通知、错误恢复functions" class="headerlink" title="错误检测、错误通知、错误恢复functions"></a>错误检测、错误通知、错误恢复functions</h3><ul>
<li>所有nodes都可以检测出错误（错误检测）</li>
<li>检测出错误的node会立即通知总线上其它nodes(错误通知)</li>
<li>正在发送消息的节点，if检测到错误，会立即停止当前的发送，并待总线空闲时不断重复发送此消息，知道改消息发送成功为止(错误恢复)</li>
</ul>
<h3 id="故障封闭"><a href="#故障封闭" class="headerlink" title="故障封闭"></a>故障封闭</h3><p>node能够判断错误的类型：暂时性地数据错误（如噪声干扰）还是持续性地数据错误（如节点内部故障），如果判断时严重的持续性错误，节点就会切断自己与总线地练习，避免影响其他nodes</p>
<h1 id="CAN通信网络结构"><a href="#CAN通信网络结构" class="headerlink" title="CAN通信网络结构"></a>CAN通信网络结构</h1><p>理解每个结构中的作用就理解了CAN</p>
<h3 id="OSI基本参照模型"><a href="#OSI基本参照模型" class="headerlink" title="OSI基本参照模型"></a>OSI基本参照模型</h3><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807003930039.png" alt="image-20230807003930039"></p>
<h3 id="CAN协议网络层次"><a href="#CAN协议网络层次" class="headerlink" title="CAN协议网络层次"></a>CAN协议网络层次</h3><p>ISO标准只对数据链路层和物理层做了规定</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807004043599.png" alt="image-20230807004043599"></p>
<h1 id="CAN协议中的帧"><a href="#CAN协议中的帧" class="headerlink" title="CAN协议中的帧"></a>CAN协议中的帧</h1><p>CAN中有5中帧结构</p>
<ul>
<li>数据帧：用于通讯节点向外传送数据。</li>
<li>遥控帧：用于向远端节点请求数据。</li>
<li>错误帧：用于向远端节点通知校验错误，请求重新发送上一个数据。</li>
<li>过载帧：用于通知远端节点：本节点尚未做好接受准备。</li>
<li>间隔帧：用于将数据帧及遥控帧与前面的帧分离开来的帧</li>
</ul>
<h2 id="数据帧与遥控帧"><a href="#数据帧与遥控帧" class="headerlink" title="数据帧与遥控帧"></a>数据帧与遥控帧</h2><ul>
<li>数据帧：包含我们要传输的数据的帧，承载发送节点要传递的数据</li>
<li>遥控帧：请求其它节点发出与本遥控帧具有相同ID号的数据帧</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807180622274.png" alt="image-20230807180622274"></p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807180646925.png" alt="image-20230807180646925"></p>
<p>遥控帧相比于数据帧缺少数据段，且遥控帧RTR位恒为隐性1，数据帧RTR位恒为显性0</p>
<blockquote>
<p>Tips:数据帧和遥控帧都分为标准帧（CAN2.0A）和扩展帧（CAN2.0B）</p>
</blockquote>
<h4 id="帧起始"><a href="#帧起始" class="headerlink" title="帧起始"></a>帧起始</h4><p>帧的最开始一位是帧起始，SOF(start of frame)，恒为显性0</p>
<p>即CAN_H and CAN_L有电位差就表示SOF，总线上开始有报文了</p>
<h4 id="仲裁段"><a href="#仲裁段" class="headerlink" title="仲裁段"></a>仲裁段</h4><p>判定报文优先级，ID号也是实现报文过滤机制的基础</p>
<p>数据帧仲裁段：</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807181639943.png" alt="image-20230807181639943"></p>
<p>遥控帧仲裁段：</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807181705793.png" alt="image-20230807181705793"></p>
<p>遥控帧RTR位恒为隐性1，数据帧RTR位恒为显性0</p>
<h4 id="仲裁过程"><a href="#仲裁过程" class="headerlink" title="仲裁过程"></a>仲裁过程</h4><ul>
<li><strong>回读机制：</strong>节点在向总线上发送报文的过程中，同时也对总线上的二进制位进行“回读”。通过这种机制，节点就可以判断出本节点发出的二进制位与总线上当前的二进制位是否一致。  </li>
<li><strong>线与机制：</strong>在总线上，显性位0能够覆盖隐性位1。</li>
</ul>
<p>当两个节点同时发送消息时会进行逐位仲裁直至分出胜负</p>
<ul>
<li><p>在Node_A获取总线的发送权之后，Node_A接着发送自己的Msg_A，因此在竞争总线的过程中不会对Msg_A的传输造成延时；</p>
</li>
<li><p>在两个节点竞争总线的过程中，不会破坏Msg_A;</p>
</li>
</ul>
<h4 id="仲裁段中的RTR，SRR和IDE位"><a href="#仲裁段中的RTR，SRR和IDE位" class="headerlink" title="仲裁段中的RTR，SRR和IDE位"></a>仲裁段中的RTR，SRR和IDE位</h4><ul>
<li><p>RTR位：Tranmission Request Bit （远程发送请求位）。在数据帧中，RTR位恒为显性位0，在遥控帧中，恒为隐性1。  </p>
<p>在ID号相同的情况下，  保证数据帧优先级高于遥控帧</p>
</li>
<li><p>SRR位：Substitutes for Remote Requests Bit（替代远程请求位），在扩展帧（数据帧或遥控帧）中，SRR恒为隐性位1，并且可以发现，扩展帧的隐性SRR位正好对应标准帧的显性RTR位，所以</p>
<p>在前11位ID号相同的情况下，保证标准数据帧的优先级高于扩展数据帧；</p>
</li>
<li><p>IDE位：Identifier Extension Bit（标识符扩展位）。在扩展帧中恒为隐性1，在标准帧中，IDE位于控制段，且恒为显性0。且扩展帧IDE位和标准帧IDE位位置对应</p>
<p>在前11位ID号相同的情况下，保证标准遥控帧的优先级一定高于扩展遥控帧。</p>
</li>
</ul>
<h4 id="报文过滤"><a href="#报文过滤" class="headerlink" title="报文过滤"></a>报文过滤</h4><p>在CAN总线中没有地址的概念，CAN总线是通过报文ID来实现收发数据的。CAN节点上都会有一个验收滤波ID表，其位于CAN节点的验收滤波器中，如果总线上的报文的ID号在某个节点的验收滤波ID表中，那么这一帧报文就能通过该节点验收滤波器的验收，该节点就会接收这一帧报文。</p>
<p>比如：Node_A发送了一帧ID号为ID_1的报文Msg_1，Node_B的验收滤波ID表中恰好有ID_1，于是乎Msg_1就会被Node_B接收。</p>
<p>报文过滤机制体现了CAN通信的两条特点：</p>
<ol>
<li><p>一对一、组播和广播</p>
</li>
<li><p>系统的柔性：正是因为CAN总线上收发报文是基于报文ID实现的，所以总线上添加节点时不会对总线上已有的节点造成影响。</p>
</li>
</ol>
<h4 id="控制段"><a href="#控制段" class="headerlink" title="控制段"></a>控制段</h4><p>数据帧和遥控帧的控制段结构相同：  </p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807195944269.png" alt="image-20230807195944269"></p>
<p>4位的DLC（DLC3、DLC2、DLC1、DLC0）代表<strong>数据长度</strong>，指示了数据段中的字节数。对于没有数据段的遥控帧，DLC表示该遥控帧对应的数据帧的数据段的字节数  </p>
<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>数据段可以包含0~8个字节的数据，从MSB（最高位）开始输出。</p>
<h4 id="CRC段"><a href="#CRC段" class="headerlink" title="CRC段"></a>CRC段</h4><p>CRC校验序列是根据多项式生成的CRC值，其计算范围包括：帧起始、仲裁段、控制段和数据段。</p>
<p>CRC界定符恒为隐性1</p>
<h4 id="ACK段"><a href="#ACK段" class="headerlink" title="ACK段"></a>ACK段</h4><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807200359857.png" alt="image-20230807200359857"></p>
<ul>
<li><p>发送节点在ACK段发送两个隐性位，即发送方发出的报文中ACK槽为隐性1</p>
</li>
<li><p>接收节点在接收到正确的报文之后会在ACK槽发送显性位0（在ACK槽中填充显性位0使总线电平变为显性0），通知发送节点正常接收结束。</p>
</li>
</ul>
<h4 id="帧结束"><a href="#帧结束" class="headerlink" title="帧结束"></a>帧结束</h4><p>帧结束段表示该帧报文的结束，由7个隐性位构成。</p>
<h2 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h2><p>在发送和接收报文时，Nodes如果检测出错误则会发送错误帧，通知其他节点，自己出错了</p>
<h3 id="错误帧的帧结构"><a href="#错误帧的帧结构" class="headerlink" title="错误帧的帧结构"></a>错误帧的帧结构</h3><p>错误帧 &#x3D; 错误标志+错误界定符</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230807222925553.png" alt="image-20230807222925553"></p>
<ul>
<li>主动错误标志：6个连续的显性位</li>
<li>被动错误标志：6个连续的隐性位</li>
<li>错误界定符：8个连续的隐性位</li>
</ul>
<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><h4 id="位填充原则"><a href="#位填充原则" class="headerlink" title="位填充原则"></a>位填充原则</h4><p>CAN协议中规定，当相同极性的电平持续五位时，则添加一个极性相反的位（接收时自动删除下一位）——均由Nodes完成</p>
<p>位填充的作用域：SOF–CRC(除去CRC界定符)之间的位流</p>
<h4 id="错误的种类"><a href="#错误的种类" class="headerlink" title="错误的种类"></a>错误的种类</h4><p>共有五种错误</p>
<ul>
<li><p>位错误 (Bit Check Error)：自己发出的和回读的不一致</p>
<blockquote>
<p>Tips:有三种例外不是位错误</p>
<ul>
<li>在仲裁区，节点向bus发送隐性位却读到显性，表示该节点仲裁失败</li>
<li>在ACK槽，表示有节点正确接收</li>
<li>该节点发送被动错误标志（发送6个连续的隐性位），可能被其他节点发送的显性电平“吃掉”了</li>
</ul>
</blockquote>
</li>
<li><p>ACK错误 (Acknowledge Error)：节点在ACK槽没有回读到显性位，即没有节点正确接收。产生ACK应答错误</p>
</li>
<li><p>填充错误 (FIll Error)：在位填充作用域中检测到连续六个同性位</p>
</li>
<li><p>CRC错误 (CRC Error)：节点发送和接收时都会计算CRC序列，不一致检测为CRC Error</p>
</li>
<li><p>格式错误：在一帧报文发送时，如果在必须发送预定值的区域内检测到了非法值，那么就检测到了一个格式错误</p>
<blockquote>
<p>Tips:CAN报文中，有预定值的区域：</p>
<ul>
<li>数据帧和遥控帧的CRC界定符、ACK界定符、EOF</li>
<li>错误帧界定符</li>
<li>过载帧界定符</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="错误通知"><a href="#错误通知" class="headerlink" title="错误通知"></a>错误通知</h3><h4 id="节点错误状态"><a href="#节点错误状态" class="headerlink" title="节点错误状态"></a>节点错误状态</h4><ul>
<li><p>主动错误状态（有说服力，较可靠）：可以正常通信；在检测到错误时，发出带有主动错误标志的错误帧（6个连续的显性位），会“覆盖”总线上其它节点的发送，于是正在发送的报文就被破坏掉了</p>
<blockquote>
<p>大家都相信主动错误状态的节点，“我发现错误了，你们收到的不算数”</p>
</blockquote>
</li>
<li><p>被动错误状态（无说服力）：可以正常通信；在检测到错误时，发出带有被动错误标志的错误帧（6个连续的隐性位），所以这个时候总线上正在传输的报文位流不会受到该被动错误帧的影响  ，没人搭理。</p>
<p>如果发出被动错误帧的节点Node_A为报文的发送节点，那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，并且Node_A不能在错误帧之后随着连续发送刚刚发送失败的那个报文。随之而来的是帧间隔，并且连带着8位隐性住的 “延迟传送” 段（即暂停段，见帧间隔）；这样总线电平就呈现出连续11位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。此时如果Node_A能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。这种机制的目的正是为了<strong>让其它正常节点 (处于主动错误) 优先使用总线</strong>  </p>
<blockquote>
<p>Tips: 处于被动错误状态，说明这个节点目前是不太可靠的，出现错误的原因可能是它本身的问题，即刚刚检测到的错误可能仅仅只有它自己遇到，正是因为这一点，整个总线才不信任它报告的错误，从而只允许它发送六个连续的隐性位，这样它才不会拖累别人  </p>
</blockquote>
</li>
<li><p>总关闭状态：整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态（冷静一段时间）</p>
</li>
</ul>
<h4 id="错误状态的转换"><a href="#错误状态的转换" class="headerlink" title="错误状态的转换"></a>错误状态的转换</h4><p>CAN节点内，有两个计数器：<strong>发送错误计数器（TEC）and 接受错误计数器（REC）</strong></p>
<blockquote>
<p>Tips:计数器的变化有个表格规定，而不是错一次+1</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808104018271.png" alt="image-20230808104018271"></p>
<p>节点错误状态的转换就是一个量变到质变的过程</p>
<h3 id="错误帧的发送"><a href="#错误帧的发送" class="headerlink" title="错误帧的发送"></a>错误帧的发送</h3><ul>
<li><p>位错误、填充错误、格式错误、ACK措误在错误产生的那一位的下一位开始发送错误帧。</p>
</li>
<li><p>CRC错误：紧随ACK界定符后的位发送错误帧。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808105739885.png" alt="image-20230808105739885"></p>
<h2 id="过载帧"><a href="#过载帧" class="headerlink" title="过载帧"></a>过载帧</h2><p>过载帧是接收节点向总线上其它节点报告自身接收能力达到极限的帧（我已经没有能力来处理你们发来的报文了）</p>
<p>过载帧包括：过载标志+过载界定符</p>
<ul>
<li><p>过载标志：连续6个显性位；</p>
</li>
<li><p>过载界定符：连续8个隐性位；</p>
</li>
<li><p>与错误帧类似，过载帧中有过载帧重整部分，且形成过载重叠标志的原因与形成措误帧中的错误重慢标志的原因是相同的</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808110424756.png" alt="image-20230808110424756"></p>
<blockquote>
<p>Tips:接收节点Node_A达到接收极限时，就会发出过载帧到总线上，显然，过载标志的6个连续显性位会屏蔽掉总线上其它节点的发送，也就是说这个时候Node_A通过发送过载帧的方式来破坏其它节点的发送，这样在Node_A发送过载帧期间，其它节点就不能成功发送报文，于是就相当于把其它节点的发送推迟了，也就是说Node_A在其发送过载帧的这段时间得以<strong>“休息”</strong>。  </p>
</blockquote>
<p>有三种情况会引起过载帧：</p>
<ul>
<li><p>接收节点自身原因。接收节点由于某种原因需要延迟接收下一个数据帧或者遥控帧。</p>
</li>
<li><p>在帧间隔的间歇段的第一位和第二位检测到一个显性位（正常的间歇段都是隐性位）</p>
<p>帧间隔的间隔段本应是三个连续的隐性位，如果接收节点Node_A在间隔段检测到显性位，那么就意味着此时有报文发向接收节点Node_A, 但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</p>
</li>
<li><p>CAN节点在错误界定符或过载界定符的第八位（最后一位）听到一个显性位0, 节点会发送一个过载帧，且错误计数器不会增加。</p>
<p>接收节点Node_A在错误界定符和过载界定符的最后一位听到显性位，也意味着有报文发向Node_A, 但这个时候是不应该有报文发来的，于是Node_A发送过载帧。</p>
</li>
</ul>
<h2 id="帧间隔"><a href="#帧间隔" class="headerlink" title="帧间隔"></a>帧间隔</h2><p>帧间隔是用来隔离数据帧（或者遥控帧）的，也就是说，数据帧（或者遥控帧）通过插入帧间隔可以将本帧与先行帧（数据帧、遥控帧、错误帧、过载帧）分隔开来。  </p>
<blockquote>
<p>Tips: 过载帧和错误帧的前面不能插入帧间隔。  </p>
</blockquote>
<p>帧间隔有两种不同的状态：</p>
<p>主动错误状态的帧间隔：<br><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808111701098.png" alt="image-20230808111701098"></p>
<p>被动错误状态的帧间隔：</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808111723987.png" alt="image-20230808111723987"></p>
<ul>
<li><p>间隔段：连续三个隐性位；间隔段期间，所有节点不允许发送数据这或遥控帧，只要在这期间监听到显性位，接收节点就会发送过载帧。</p>
</li>
<li><p>空闲段：连续隐性位，个数不一定，个或者多个都可以。总线空闲的时间是任意长的，只要总线空闲，节点就可以竞争总线。</p>
</li>
<li><p>暂停段：只有处于被动错误状态的节点在发送帧间隔的时候，才会在帧间隔中插入8个连续隐性位的暂停段。</p>
<p>暂停段，又叫做延迟传送段，为什么节点处于被动状态时会有这样一段呢？原因如下：首先，考虑主动错误状态的节点Node_A, 发送主动错误标志之后，随之就要重新发送刚刚发送失败的报文，但是为了间隔开与前面刚刚发送的错误帧，总线在错误帧之后就会插入3个隐形位的帧间隔，在这3个隐形位期间，其它的节点不足以判定总线空闲（需要连续11个隐性位才能判定），所以Node_A仍然占据着总线的控制权，于是在帧间隔之后，Node_A能够接着发送报文。现在Node_A转入到被动错误状态了，说明它已经不是很可靠了，这个时候如果没有延迟传送段，在Node_A发出被动错误标志之后，它仍然能够在3位的帧间隔之后立即重新发送报文，这是不符合我们对被动错误状态的处理要求的当然也是不符合CAN协议的，于是乎对于发送出被动错误标志的节点，总线在帧间隔中加入了8 个连续隐性位的延迟传送段，这样的3+8&#x3D;11个连续隐性位。<strong>就能让Node_A在这个帧间隔期间失去对总线的控制权，从而优先保证其它正常（处于主动错误状态）节点能够使用总线，而不必等着一个已经不可靠的Node_A占据总线。</strong></p>
</li>
</ul>
<h1 id="CAN通信的位定时与同步"><a href="#CAN通信的位定时与同步" class="headerlink" title="CAN通信的位定时与同步"></a>CAN通信的位定时与同步</h1><h2 id="位定位"><a href="#位定位" class="headerlink" title="位定位"></a>位定位</h2><p>CAN总线是两项调制，即此时数值上波特率和比特率（见Bonus）是一样的。</p>
<h3 id="位时间"><a href="#位时间" class="headerlink" title="位时间"></a>位时间</h3><h4 id="位时间的基本概念"><a href="#位时间的基本概念" class="headerlink" title="位时间的基本概念"></a>位时间的基本概念</h4><p>表示一个二进制位在总线上传输时所需要的时间。<br>$$<br>位速率&#x3D;\frac{1}{位时间}<br>$$<br>CAN总线中的两个时钟：晶振时钟周期+CAN时钟周期  </p>
<ul>
<li><p>晶振时钟周期：是由单片机振荡器的晶振频率决定的，指的是振荡器每震荡一次所消耗的时间长度，也是整个系统中最小的时间单位。</p>
</li>
<li><p>CAN时钟周期：CAN时钟是由系统时钟分频而来的一个时间长度值，实际上就是一个时间份额Tq。<br>$$<br>CAN时钟周期 &#x3D; 2×晶振时钟周期×BRP<br>$$</p>
<blockquote>
<p>BRP即波特率预分频值（baudrate prescaler）:它的作用是将晶振频率进行预分频，以满足CAN总线波特率的要求。 在CAN协议中，BRP的取值范围是<strong>1~64</strong>，它决定了一个时间单元（Time Quantum，Tq）的长度。</p>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808135508935.png" alt="image-20230808135508935"></p>
<h4 id="位时间的分段"><a href="#位时间的分段" class="headerlink" title="位时间的分段"></a>位时间的分段</h4><p>在CAN的位定时中，一个CAN时钟周期称为一个时间量子一Tq（Time Quantum）</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808135931239.png" alt="image-20230808135931239"></p>
<ul>
<li>同步段 (Synchronization Segment) :<ul>
<li>长度固定，1个时间量子Tq；</li>
<li>一个位的传输从同步段开始；</li>
<li>同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。</li>
</ul>
</li>
<li>传播段 (Propagation Segment)：<ul>
<li>传播段用于补偿报文在总线和节点上传输时所产生的时间延迟；</li>
<li>传播段时长$≥2×$报文在总线和节点上传输时产生的时间延迟；</li>
<li>传播段时长可编程 (1~8个时间量子Tq)。</li>
</ul>
</li>
<li>相位缓冲段1 (Phase Buffer Segment)：<ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段加长；</li>
<li>在这个时间段的末端进行总线状态的采样；</li>
<li>长度可编程 (1~8个时间量子Tq)。</li>
</ul>
</li>
<li>相位冲段2 (Phase Buffer Segment2) :  <ul>
<li>用于补偿节点间的晶振误差；</li>
<li>允许通过重同步对该段缩短；</li>
<li>长度可编程 (1~8个时间量子Tq)。</li>
</ul>
</li>
</ul>
<p>$$<br>tBit &#x3D; tSS+tPS+tPBS1+tPBS2<br>$$</p>
<p>$$<br>tBit：位时间，tSS：同步段时间，tPS：传播段时间，tPBS1：相位缓冲时间段1，tPBS2：相位缓冲时间段2<br>$$</p>
<h2 id="CAN的同步机制"><a href="#CAN的同步机制" class="headerlink" title="CAN的同步机制"></a>CAN的同步机制</h2><p>CAN有两种同步机制：<strong>硬同步+重同步</strong></p>
<ul>
<li>一个位时间内只允许一种同步方式，要么硬同步要么重同步；</li>
<li>任何一个从 “隐性” 到 “显性”的下降沿都可以用于同步；</li>
<li>硬同步发生在报文的SOF位，所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；</li>
<li>重同步发生在一个报文SOF位之外的其它段，当下降沿落在了同步段之外时发生重同步；</li>
<li>在SOF到仲裁场发送的时间段内，如果有多个节点同时发送报文，那么这些发送节点对跳变沿不进行重同步。</li>
</ul>
<h3 id="硬同步"><a href="#硬同步" class="headerlink" title="硬同步"></a>硬同步</h3><p>硬同步发生在SOF位，所有接收节点调整各自当前位的同步段，调整宽度不限  </p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808141854318.png" alt="image-20230808141854318"></p>
<h3 id="重同步"><a href="#重同步" class="headerlink" title="重同步"></a>重同步</h3><p>在两个缓冲段中间的位置，即使读取总线电平的采样点位置，当检测到总线上存在相位差的时候，通过延长PBS1或缩短PBS2来获得同步。这两个相位缓冲段的延长or缩短时间上限再有同步跳转宽度SJW给定。</p>
<blockquote>
<p>Tips:CAN是异步通信，需要通过不断地重新同步才能保证收发节点的采样准确。所以SJW决定了接收节点是否能有比较好的兼容性。</p>
</blockquote>
<h4 id="PBS1延长"><a href="#PBS1延长" class="headerlink" title="PBS1延长"></a>PBS1延长</h4><p>发的晚，收的早，导致PBS1延长</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808142134094.png" alt="image-20230808142134094"></p>
<h4 id="PBS2缩短"><a href="#PBS2缩短" class="headerlink" title="PBS2缩短"></a>PBS2缩短</h4><p>发的早，收的晚，导致PBS2缩短</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808142317458.png" alt="image-20230808142317458"></p>
<h4 id="同步跳转宽度"><a href="#同步跳转宽度" class="headerlink" title="同步跳转宽度"></a>同步跳转宽度</h4><p>在重同步时，有个同步跳转宽度 (SJW,Synchro Jump Width) 的概念，表示的是PBS1和PBS2重同步时允许跳转的最大宽度，SJW决定了接收节点是否能有比较好的兼容性。同步跳转宽度必须满足以下几个条件：</p>
<ul>
<li><p>SJW必须小于PBS1和PBS2的最小值</p>
</li>
<li><p>SJW最大值不能超过4</p>
</li>
</ul>
<h2 id="位定时参数"><a href="#位定时参数" class="headerlink" title="位定时参数"></a>位定时参数</h2><ul>
<li><p>位速率：bps、kbps、Mbps</p>
</li>
<li><p>位时间：tBit，单位一般为纳秒ns</p>
</li>
<li><p>时间量子Tq：<br>$$<br>Tq&#x3D;\frac{1}{NBT},NBT：一个位时间内包含Tq的个数<br>$$</p>
</li>
<li><p>传输延迟时间tPTS</p>
<p>CAN报文在CAN总线上的传输时，物理延迟包括两个部分：</p>
<ul>
<li>在CAN-BUS上传输造成的延迟</li>
<li>在节点上传输造成延迟</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230808144634176.png" alt="image-20230808144634176"></p>
<p>按照CAN通信协议的规定，补偿给传播延迟的时间长度要至少等于实际实际传播延迟时长的2倍，即:<br>$$<br>tPTS≥2×t_{del} &#x3D; 2×(t_{el}+t_{Bus})<br>$$</p>
<blockquote>
<p>Tips：在CAN总线通信系统中是以时间量子Tq来度量时间的，所以如果延迟补偿时间tPTS&#x3D;3.1Tq, 那么这个时候要取：tPTS&#x3D; 4Tq。</p>
</blockquote>
<ul>
<li><p>相位缓冲段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (NBT-1-tPTS_Tq)/2==偶数</span><br><span class="line">	PBSl_Tq = PBS2_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">else</span><br><span class="line">	PBSl_Tq = (NBT-1-tPTS_Tq)/2</span><br><span class="line">	PBS2_Tq = PBSl_Tq + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步跳转宽度：<br>$$<br>SJW&#x3D;min(PBS1_Tq,PBS2_Tq,4)<br>$$</p>
</li>
<li><p>验证晶振误差Df</p>
</li>
</ul>
<p>  晶振误差必须满足三个条件</p>
<ul>
<li><p>$$<br>Df&lt;&#x3D;\frac{SJW}{(2<em>10</em>NBT)}<br>$$</p>
</li>
<li><p>$$<br>Df&lt;&#x3D;\frac{min(PBS1_Tq,PBS2_Tq)}{2*(13*NBT-PBS2_Tq)}<br>$$</p>
</li>
<li><p>$$<br>Df&lt;&#x3D;1.58%<br>$$</p>
</li>
</ul>
<h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><h3 id="比特率、波特率和频率带宽"><a href="#比特率、波特率和频率带宽" class="headerlink" title="比特率、波特率和频率带宽"></a>比特率、波特率和频率带宽</h3><ul>
<li>比特率（bit rate）：每秒传送的比特数量，又称为传信率，信息传输率，位速率。比特率基本单位为bit&#x2F;s或bps，全称为bit per second</li>
<li>波特率（Baud）：每秒钟传送的符号（码元）数量，又称为传码率，信号传输率，单位是波特（Baud、B，即symbol&#x2F;s）。在通信系统中，携带数据信息的信号单元称为码元，也称为符号（symbol）。</li>
</ul>
<table>
<thead>
<tr>
<th>码元类型</th>
<th>码元状态</th>
<th>码元状态总数量</th>
<th>码元所需比特位数</th>
</tr>
</thead>
<tbody><tr>
<td>2种状态的码元</td>
<td>0、1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4种状态的码元</td>
<td>00、01、10、11</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>8种状态的码元</td>
<td>000、001、010、100、011、101、110、111</td>
<td>8</td>
<td>3</td>
</tr>
</tbody></table>
<p>$$<br>比特位数&#x3D;log_2N,N为码元状态数<br>$$</p>
<p>$$<br>比特率Rb&#x3D;波特率Rs*log_2N(仅考虑信息净荷)<br>$$</p>
<p>频谱带宽其实是通信信号的最高频率与最低频率的差值。</p>
<p>波特率越高，比特率越高，所占用的信道频谱带宽也越大</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。就是一个网络连接到另一个网咯的“关口”。</p>
<p>网关实质上是<strong>一个网络通向其他网络的IP地址</strong>。</p>
<h3 id="OCR识别"><a href="#OCR识别" class="headerlink" title="OCR识别"></a>OCR识别</h3><p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程。</p>
<p>福昕PDF阅读器自带的快速识别功能（可秒杀一众OCR专业工具），墙裂推荐</p>
<blockquote>
<p>但实际使用并不是完全好，有意思的是我遇到 “一位” 被识别为 “T立”，“。”被识别为“0”。特别是对数学公式的识别一言难尽。。。</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/630588317">一文搞懂比特率和波特率 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_40528417/article/details/79476186">CAN总线学习笔记（1）- CAN基础知识_关于can通讯的重点和难点_weixin_40528417的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_40528417/article/details/79534483?spm=1001.2014.3001.5502">CAN总线学习笔记（2）- CAN协议数据帧与遥控帧_weixin_40528417的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_40528417/article/details/79771270?spm=1001.2014.3001.5502">CAN总线学习笔记（3）- CAN协议错误帧_weixin_40528417的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_40528417/article/details/79871311?spm=1001.2014.3001.5502">CAN总线学习笔记（4）- CAN协议过载帧和帧间隔_weixin_40528417的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/weixin_40528417/article/details/79936476?spm=1001.2014.3001.5502">CAN总线学习笔记（5）- CAN通信的位定时与同步_weixin_40528417的博客-CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165142303">什么是网关，网关的作用是什么？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65226634">一文搞懂网络知识，IP、子网掩码、网关、DNS、端口号 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.dianyuan.com/article/46751.html">CAN总线同步跳转宽度的作用-电源网 (dianyuan.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>robomaster</tag>
        <tag>CAN</tag>
      </tags>
  </entry>
  <entry>
    <title>各种通信方式</title>
    <url>/2023/07/29/%E5%90%84%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>了解及总结（同步通信-异步通信-全双工通信-串行通信-并行通信）各种通信方法</p>
<span id="more"></span>

<h1 id="并行通信-and-串行通信"><a href="#并行通信-and-串行通信" class="headerlink" title="并行通信 and 串行通信"></a>并行通信 and 串行通信</h1><h2 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h2><p>Parallel communication</p>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><p>多个数据bit位同时传输</p>
<h4 id="常用总线"><a href="#常用总线" class="headerlink" title="常用总线"></a>常用总线</h4><p>local bus,  DDR</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>同时传输，效率高</li>
<li>数据线多，设计复杂</li>
</ul>
<h2 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h2><p>Serial communication </p>
<h4 id="传输方式-1"><a href="#传输方式-1" class="headerlink" title="传输方式"></a>传输方式</h4><p>数据bit一位一位传输</p>
<h4 id="常用总线-1"><a href="#常用总线-1" class="headerlink" title="常用总线"></a>常用总线</h4><p>local bus,  DDR</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>按bit逐位传输，效率低</li>
<li>只需一根数据线，设计简单</li>
</ul>
<h1 id="异步串行通信-and-同步串行通信"><a href="#异步串行通信-and-同步串行通信" class="headerlink" title="异步串行通信 and 同步串行通信"></a>异步串行通信 and 同步串行通信</h1><h2 id="异步串行通信"><a href="#异步串行通信" class="headerlink" title="异步串行通信"></a>异步串行通信</h2><p>Asynchronous serial communication</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息发送设备与接收设备之间无时钟连接</li>
<li>信息中包含特殊标志位Start&#x2F;Stop</li>
<li>接收设备根据特殊标志位利用本地时钟对数据采样</li>
</ul>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>UART，无时钟线连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收器   发送器</span><br><span class="line">TxD-----&gt;RxD</span><br><span class="line">RxD&lt;-----TxD</span><br></pre></td></tr></table></figure>



<h2 id="同步串行通信"><a href="#同步串行通信" class="headerlink" title="同步串行通信"></a>同步串行通信</h2><p>Synchronous serial communciation</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息发送设备与接收设备需要时钟同步</li>
<li>两者间出数据线连接，还需要额外的时钟线连接</li>
</ul>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>IIC,需要时钟线SCL连接</p>
<h1 id="三种数据通路：单工，半双工，全双工"><a href="#三种数据通路：单工，半双工，全双工" class="headerlink" title="三种数据通路：单工，半双工，全双工"></a>三种数据通路：单工，半双工，全双工</h1><h2 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h2><p>Simplex communciation</p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>信息只能单一方向传输</li>
</ul>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><p>广播，遥控器</p>
<h2 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h2><p>Half-duplex communciation</p>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数据支持双向传输</li>
<li>发送和接收不能同时进行，同一时间只能发送or接收数据</li>
</ul>
<h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><p>IIC</p>
<h2 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h2><p>Full-duplex communciation</p>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul>
<li>数据支持双向传输</li>
<li>数据接收和发送同时进行</li>
</ul>
<h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><p>电话、网口、UART</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>B站视频：【四分钟搞定【同步通信-异步通信-全双工通信-串行通信-并行通信】】<a href="https://www.bilibili.com/video/BV1q64y1R72M?vd_source=93bb338120537438ee9180881deab9c1">https://www.bilibili.com/video/BV1q64y1R72M?vd_source=93bb338120537438ee9180881deab9c1</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于cubeMX创建的第一个stm32工程</title>
    <url>/2023/08/04/%E5%9F%BA%E4%BA%8EcubeMX%E5%88%9B%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAstm32%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Main-Takeaway"><a href="#Main-Takeaway" class="headerlink" title="Main Takeaway"></a>Main Takeaway</h1><p>记录我的基于STM32Cube框架的第一个stm32程序从新建到编译上传全流程，感谢机协学长学姐的帮助！</p>
<span id="more"></span>

<h1 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h1><ul>
<li>通过STM32CubeMX选择芯片、配置外设，并生成代码</li>
<li>在选用的编辑器中编辑代码，编写程序</li>
<li>编译代码，生成二进制文件并上传</li>
<li>调试代码的运行效果</li>
</ul>
<h1 id="芯片配置"><a href="#芯片配置" class="headerlink" title="芯片配置"></a>芯片配置</h1><h3 id="选择芯片-开发板"><a href="#选择芯片-开发板" class="headerlink" title="选择芯片&#x2F;开发板"></a>选择芯片&#x2F;开发板</h3><p>但是需要注意，若选择官方开发板作为硬件，则会提供“按照开发板上的电路及布局默认配置硬件”的选项</p>
<h3 id="配置内核与外设硬件"><a href="#配置内核与外设硬件" class="headerlink" title="配置内核与外设硬件"></a>配置内核与外设硬件</h3><p><strong>系统配置</strong>：时钟配置+调试配置</p>
<p><strong>时钟配置</strong>（必要）：STM32有四个时钟源：LSI（低速内部时钟）、LSE（低速外部时钟）、HIS（高速内部时钟）和HSE（高速外部时钟）；有的型号仅有其中某几个。默认的配置是采用芯片内部自带的振荡器、主频配置为8MHz。Nucleo F103RB中芯片外接了8MHz的晶振，故将“HSE”项配置为“Crystal&#x2F;Ceramic Resonator”，这就是说使用高速外部时钟，且时钟源为晶振。具体频率则在时钟树界面中配置（在使用内部振荡器时F1系列芯片最高主频是64MHz，在使用8MHz外部晶振时最高主频是72MHz。）</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605232417189.png" alt="image-20230605232417189"></p>
<p><strong>调试配置</strong>：用于配置调试的类型（如果芯片未被配置为调试模式就强行对其进行调试，则会造成芯片内部启动程序错误而导致之后无法正常烧录程序，此时需擦除其Flash以修复）</p>
<p>主流的调试方式有SWD和JTAG两种，而SWD是更方便的方法。若要使用SWD进行调试，则必须将芯片配置为“Serial Wire”调试。</p>
<p><strong>外设硬件</strong>：芯片中的所有外设都可以在软件中配置，包括DMA、ADC、定时器等</p>
<h3 id="配置工程，生成代码"><a href="#配置工程，生成代码" class="headerlink" title="配置工程，生成代码"></a>配置工程，生成代码</h3><h4 id="工程名称，路径"><a href="#工程名称，路径" class="headerlink" title="工程名称，路径"></a>工程名称，路径</h4><h4 id="应用结构："><a href="#应用结构：" class="headerlink" title="应用结构："></a><strong>应用结构</strong>：</h4><p>应用结构有“Basic”和“Advanced”两个选项。如果观察仔细的话，会发现STM32CubeIDE工程中的CubeMX项目默认的是“Advanced”结构，而单独使用CubeMX默认的是“Basic”结构</p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605232417189.png" alt="image-20230605232417189"></h6><h4 id="工具链-IDE："><a href="#工具链-IDE：" class="headerlink" title="工具链&#x2F;IDE："></a>工具链&#x2F;IDE：</h4><p>STM32CubeMX除了配置硬件外，还提供了直接生成工程		的功能，即由该“工具链&#x2F;IDE”选项确定。STM32CubeMX预先包含了7种		开发方式，分别是：EWARM、MDK-ARM、SW4STM32、TrueStudio、		STM32CubeIDE、Makefile和Other Toolchains(GPDSC)</p>
<p>****MDK-ARM****：Keil uVision采用的开发环境，使用此选项可以直接生成Keil完整工程。</p>
<p>****TrueStudio、STM32CubeIDE****：TrueStudio是STM32CubeIDE的前身。TrueStudio本身是以Eclipse为基础配置而成的STM32开发工具，在被ST收购被ST与STM32CubeMX合并，形成了STM32CubeIDE。故该两种选项生成的项目并无较大区别。对于使用Eclipse自行配置来为STM32开发的同学，也可以选择该选项。</p>
<p>****Makefile****：Makefile实际上是“make”这个程序为了实现自动化构建工程而读取的一种文件。make从Makefile文件中读取生成的对象、编译的顺序、文件的依赖等信息，然后使用gcc或者g++来编译。Makefile不仅适用于系统下的标准C&#x2F;C++工程，也适用于嵌入式开发。为Arm架构芯片开发的gcc叫做“arm-none-eabi-gcc”，可以在GNU的官网上下载。PlatformIO使用gcc来编译STM32的程序，故采用Makefile选项更搭配。</p>
<p>但实际上PlatformIO自带一套使用Python来构建工程的方法，因此用不到Makefile；真正需要的只是“Inc”和“Src”两个文件夹中的代码而已。如果有同学有兴趣的话，可以尝试使用gcc搭配make自行搭建一套工具链，这个时候STM32CubeMX生成的Makefile文件就会派上用场。</p>
<h4 id="包管理："><a href="#包管理：" class="headerlink" title="包管理："></a>包管理：</h4><p>包管理有三种选项，翻译过来就是：仅复制用到的库文件、复制所有库文件、仅添加引用。</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605232846792.png" alt="image-20230605232846792"></p>
<p>当选择了复制库文件到工程时，除了Inc和Src两个文件夹（或Advanced模式下的Core文件夹）外，还会额外生成一个Driver文件夹，其中放置的便是STM32的库文件。当启用了USB或者FreeRTOS等中间件后，也还会额外生成一个Middleware文件夹，其中放置的便是中间件的库文件。文件结构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605233921565.png" alt="image-20230605233921565"></p>
<h4 id="生成选项："><a href="#生成选项：" class="headerlink" title="生成选项："></a>生成选项：</h4><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230605233713820.png" alt="image-20230605233713820"></p>
<h1 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h1><p>&#x2F;* USER CODE BEGIN x *&#x2F; *</p>
<p> &#x2F;* USER CODE END x *&#x2F;</p>
<p>其中的x可以是数字，也可以是别的一些标识符。STM32CubeMX希望用户将自己的代码插入到“BEGIN”和“END”当中，</p>
<p><strong>reason:</strong></p>
<p>之所以要这样做是因为STM32CubeMX在更新代码时不会修改这两句注释之间的内容。比如当用户的需求发生了变动，需要修改硬件配置时，就需要使用STM32CubeMX来修改并重新生成代码。如果将用户代码放在这两句注释之间，STM32CubeMX就不会在重新生成代码的时候覆盖掉这部分。这使得硬件配置的更改变得更加方便</p>
<h1 id="编译上传"><a href="#编译上传" class="headerlink" title="编译上传"></a>编译上传</h1><p>单片机、乃至目前一切电脑都不能直接运行代码文件，必须通过编译器将代码文件编译成CPU能够处理的机器语言——即二进制机器指令——才能烧录到芯片执行。STM32主流的编译器——也即arm芯片所用的编译器——有两种：arm-gcc和Arm Compiler。Keil默认采用Arm Compiler，而STM32CubeIDE和PlatformIO则采用arm-gcc。二者在编译原理上有差别，但是在代码层面很难体现出来</p>
<h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><p>ST-Link不只是程序下载器，还是调试器，能够通过JTAG接口或者SWD接口控制芯片的运行、读取芯片的寄存器、内存等。我们可以观察到芯片中每个寄存器的值、每个变量的值及其变化，可以通过断点让程序运行到指定的位置、检测中断的执行；从而能够方便地调试代码。</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>STM32CubeMX软件生成出来的代码具有高度的结构性。按文件予以区分，各个文件的功能如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>stm32f1xx_it.h&#x2F;stm32f1xx_it.c</td>
<td>实现stm32的所有中断程序</td>
</tr>
<tr>
<td>stm32f1xx_hal_conf.h</td>
<td>HAL库配置文件</td>
</tr>
<tr>
<td>system_stm32f1xx.c</td>
<td>在内核层面上设置系统时钟</td>
</tr>
<tr>
<td>stm32f1xx_hal_msp.c</td>
<td>特定单片机具体配置</td>
</tr>
<tr>
<td>main.h</td>
<td>包含了应用程序全局的定义</td>
</tr>
<tr>
<td>main.c</td>
<td>实现主程序</td>
</tr>
<tr>
<td>gpio.h&#x2F;gpio.c（以及类似的tim、usart等）</td>
<td>专门配置某个外设硬件</td>
</tr>
</tbody></table>
<p>接下来将逐个讲解这些文件的功能。</p>
<h3 id="文件与程序功能"><a href="#文件与程序功能" class="headerlink" title="文件与程序功能"></a>文件与程序功能</h3><h4 id="stm32f1xx-hal-conf-h："><a href="#stm32f1xx-hal-conf-h：" class="headerlink" title="stm32f1xx_hal_conf.h："></a>stm32f1xx_hal_conf.h：</h4><p>该文件定义了启用的HAL模块，并设置了一些宏参数——比如晶振频率等。此处仅仅介绍模块启用的相关代码。</p>
<p>C&#x2F;C++中的宏常用于选择性编译的程序，此处即使用了此原理。通过一系列宏来确定需要引用哪些头文件</p>
<p>只有定义了对应的宏，才会引用对应的头文件，对应的模块才能够在应用中使用。这些宏不需要使用者手动定义，STM32CubeMX会自动根据在软件中选择的配置来定义这些宏、启用对应的模块。</p>
<h4 id="system-stm32f1xx-c"><a href="#system-stm32f1xx-c" class="headerlink" title="system_stm32f1xx.c"></a>system_stm32f1xx.c</h4><p>该文件不涉及任何HAL库中的内容，仅仅从内核上使用寄存器的方式来初始化时钟，并提供了时钟频率值更新的函数。该文件中包含两个函数，如下所示：</p>
<table>
<thead>
<tr>
<th>SystemInit()</th>
<th>按照默认配置设置系统时钟、嵌入式Flash等</th>
</tr>
</thead>
<tbody><tr>
<td>SystemCoreClockUpdate()</td>
<td>根据当前的配置计算芯片主频</td>
</tr>
</tbody></table>
<p>这两个函数在代码中都没有显式调用。实际上SystemInit()的调用是写在启动文件中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Call the clock system intitialization function.*/  </span><br><span class="line">bl  SystemInit</span><br></pre></td></tr></table></figure>

<p>其调用发生在复位后、进入主函数前。其实本来可以通过修改该函数的参数就能实现时钟树的配置，但是HAL库选择了以自己的方法实现时钟配置，因此SystemInit()函数仅仅实现了默认的时钟配置，也就是采用内部时钟、主频为8MHz。真正的时钟配置是在主函数中进行的。</p>
<h4 id="stm32f1xx-it-h-stm32f1xx-it-c"><a href="#stm32f1xx-it-h-stm32f1xx-it-c" class="headerlink" title="stm32f1xx_it.h&#x2F;stm32f1xx_it.c"></a>stm32f1xx_it.h&#x2F;stm32f1xx_it.c</h4><p>这两个文件包含了单片机用到的所有中断服务程序，主要分为两个部分：内核中断和外设中断。</p>
<h5 id="内核中断"><a href="#内核中断" class="headerlink" title="内核中断"></a>内核中断</h5><p>在代码中内核中断以以下注释作为开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**********************************************************************/ /*    Cortex-M3 Processor Interruption and Exception Handlers     */  /**********************************************************************/</span><br></pre></td></tr></table></figure>

<p>内核中断指的是那些由STM32芯片中内核部分——包括F1系列采用的Cortex-M3内核、F4系列采用的Cortex-M4内核等——产生的中断。这些中断多是一些通用的、系统性的中断，如SysTick_Handler（系统滴答定时器中断）、HardFault_Handler（硬件错误中断）等。STM32CubeMX将其自动列出来，方便使用者修改。比如HardFault_Handler，当系统出现硬件错误的时候便会跳转到这里，可以利用这一中断函数很快定位bug的来源。</p>
<p>注意，内核中断中的SysTick_Handler默认被HAL库用于计时。如果没有实现该中断函数则会使HAL库失去计时功能。当然这也是已经由STM32CubeMX软件自动完成了，可以在SysTick_Handler函数中看见被调用的库函数HAL_IncTick。</p>
<p> 系统滴答定时器中断：由系统滴答定时器产生</p>
<p> 硬件错误中断：当发生内存溢出、访问越界、堆栈溢出时进入</p>
<p> HAL库计时功能默认采用系统滴答定时器来进行计时，但也可以换用TIM1、TIM2等外设计时器：可在STM32CubeMX的SYS部分配置</p>
<h5 id="外设中断"><a href="#外设中断" class="headerlink" title="外设中断"></a>外设中断</h5><p>在代码中外设中断以以下注释作为开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**********************************************************************/ /* STM32F1xx Peripheral Interrupt Handlers                 */ /* Add here the Interrupt Handlers for the used peripherals.      */ /* For the available peripheral interrupt handler names,         */ /* please refer to the startup file (startup_stm32f1xx.s).        */ /**********************************************************************/</span><br></pre></td></tr></table></figure>

<p>外设中断指的是由单片机内非内核部分的外设硬件产生的中断，如定时器中断、外部中断、串口中断等。当在STM32CubeMX中选择了相应的中断时便会自动在此处添加中断服务函数。</p>
<h4 id="stm32f1xx-hal-msp-c"><a href="#stm32f1xx-hal-msp-c" class="headerlink" title="stm32f1xx_hal_msp.c"></a>stm32f1xx_hal_msp.c</h4><p>MSP指的是MCU Specific Package，即单片机具体方案。HAL库体系下，初始化分为两个步骤：抽象层初始化和MSP初始化。</p>
<p>以串口为例。串口的属性包括波特率、数据位、校验位等；但是这些属性属于抽象属性，无论这个串口是STM32单片机的串口1还是串口2，或者是Arduino上的甚至51单片机上的串口，都拥有这些属性。抽象属性的初始化即为抽象层的初始化。但是要让串口真正工作起来，仅仅告诉它波特率多少、数据位多少、有无校验位是不够的，还要配置串口的时钟、串口的DMA、串口的复用引脚等，而这些属性在不同单片机上是不一样的。这些初始化即为MSP初始化。只有经过了这两层初始化，开发者才能按照需求使用抽象硬件。</p>
<p>该文件实现的即是单片机全局的MSP初始化函数：HAL_MspInit()。如下所示，实现了复用引脚和电源的时钟使能，并且关闭了JTAG调试而改用SWD调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> \* Initializes the Global MSP.</span><br><span class="line"> */</span><br><span class="line">void HAL_MspInit(void)</span><br><span class="line">&#123;</span><br><span class="line"> __HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line"> __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line"> /* System interrupt init*/</span><br><span class="line"></span><br><span class="line"> /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled</span><br><span class="line"> */</span><br><span class="line"> __HAL_AFIO_REMAP_SWJ_NOJTAG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数并非在源文件中进行调用，而是在库文件中进行调用。HAL库的初始化函数在进行完毕抽象层的初始化后便会调用相应的MSP初始化函数。</p>
<h4 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h4><p>该文件包含了全局的宏定义，并且包含了单片机的库文件。从STM32Cube的设计上来看，官方希望开发者将全局的定义、包含、常量等都写在该文件中，并在各个源文件中都包含该main.h</p>
<p>文件中为开发者预留了填写包含（Private includes）、类型（Exported types）、常量（Exported constants）、宏函数（Exported macro）、函数原型（Exported functions prototypes）和宏定义（Private defines）。用户可将自己的代码填写在“USER CODE BEGIN”和“USER CODE END”之间。</p>
<p>Tips:</p>
<p>由于用户可能多次使用STM32CubeMX进行代码生成，故代码文件中的内容会被多次重写。如果要修改生成的源文件，请务必将代码填写在“USER CODE BEGIN”和“USER CODE END”之间，因为STM32CubeMX在重新生成代码时会识别该标志并保留其中的用户代码。</p>
<h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><p>在main函数中，首先初始化了HAL库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">HAL_Init();</span><br></pre></td></tr></table></figure>

<p>然后配置了系统时钟。此处的时钟配置和之前的SystemInit函数不一样，SystemInit函数中直接修改寄存器配置时钟，而此处则使用HAL库的库函数来配置；该函数也在main.c文件中实现，将单片机的时钟配置成软件中时钟树所配置成的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Configure the system clock */ SystemClock_Config();</span><br></pre></td></tr></table></figure>

<p>其次初始化了所有外设。本例中仅有GPIO进行了初始化，因此此处也仅有GPIO的初始化函数。以后若有其他外设需要初始化，CubeMX也会将其放在该位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialize all configured peripherals */ MX_GPIO_Init();</span><br></pre></td></tr></table></figure>

<p>接下来便进入死循环。单片机上的程序不像我们电脑上的程序；电脑上的程序运行结束后就由操作系统回收资源了，单片机上的程序则会一直运行，从主函数返回后就回到了汇编启动文件中，接下来单片机的行为就不是我们在C语言代码中可以控制的了。因此在main函数中写入一个死循环，程序就不会从main函数退出。而实际的应用场景中，我们需要实现的功能很多时候也正是需要写在死循环中不断去执行，本例中的LED灯闪烁。</p>
<h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>stm32的工程为C语言工程，编译时不会产生元数据，全靠头文件的包含和源文件的编译链接来实现工程组成，因此尤其需要开发者设计好合适的工程结构。</p>
<p>关于C语言工程的结构，网上有许多的文章都提供了如何组织代码的方法。实际上代码的组织并没有一个非常统一的方案，大多都是按照开发者自己的喜好来设计。此处也不会要求同学们使用某种代码组织方法，仅仅提供笔者使用的代码结构供参考。</p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131555059.png" alt="image-20230606131555059"></p>
<p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131609394.png" alt="image-20230606131609394"></p>
<p>当程序的逻辑逐渐复杂的时候，也可以不仅仅使用一对App.h&#x2F;c文件来实现全部逻辑，而可以使用多个文件分别实现一部分，此处不详述。</p>
<h4 id="一些别的原则"><a href="#一些别的原则" class="headerlink" title="一些别的原则"></a>一些别的原则</h4><ul>
<li><p>不要包含源文件，而是包含头文件；头文件中也不要包含函数或者全局变量的定义，而仅仅包含其声明。将函数的定义放在源文件里，函数的声明放在头文件中；变量的定义放在源文件里，再在头文件中将其extern</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/image-20230606131804276.png" alt="image-20230606131804276"></p>
</li>
<li><p>使用易理解函数、类型、变量名称。杜绝使用意义不明的命名，如a、b、l、m等，而要使用意义明确的名字，如使用单词或者易于理解的缩写来描述。此处不推荐使用拼音进行命名。如下展示的是STM32的HAL库中的一个函数命名作为示例</p>
<table>
<thead>
<tr>
<th><em><strong>*函数名：HAL_GPIO_WritePin*</strong></em></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*HAL*</strong></em></td>
<td><em><strong>*GPIO*</strong></em></td>
<td><em><strong>*WritePin*</strong></em></td>
</tr>
<tr>
<td>该函数隶属于HAL库</td>
<td>该函数与GPIO相关</td>
<td>该函数的功能是写引脚的值</td>
</tr>
</tbody></table>
</li>
<li><p>使用规律的命名规则。常见的几种基础的命名规则如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>驼峰命名</th>
<th>组成变量名的第一个单词的首字母小写，其余的首字母大写。Arduino采用的便是驼峰命名规则，如analogWrite，attachInterrupt等。</th>
</tr>
</thead>
<tbody><tr>
<td>帕斯卡命名</td>
<td>组成变量名的各个单词的首字母均大写。C#就常用帕斯卡命名规则，如Console.WriteLine，XmlSerializer等。</td>
</tr>
<tr>
<td>下划线命名</td>
<td>组成变量名的单词均为小写，其间使用下划线连接。树莓派Pico的SDK采用的便是下划线命名，如hw_set_bits、sleep_ms</td>
</tr>
</tbody></table>
<p>这些命名规则仅仅作为参考，实际上可以使用混合的命名规则，比如公共成员使用帕斯卡命名、私有成员使用驼峰命名，或者在一个变量中使用组合式的命名规则。但是在整个工程中对象的命名规则务必有迹可循。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>robomaster</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
</search>
