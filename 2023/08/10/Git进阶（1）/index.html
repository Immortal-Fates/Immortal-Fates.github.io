<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 6.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link href=/lib/font-awesome/css/all.min.css rel=stylesheet><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><meta content="Main Takeaway Git进阶（1）——了解Git是什么，Git的配置和所有 Git 基本的本地操作 希望通过Git - Book (git-scm.com)+Learn Git Branching来进一步掌握Git Learn to love the command line. Leave the IDE behind." name=description><meta content=article property=og:type><meta content=Git进阶（1） property=og:title><meta content=http://example.com/2023/08/10/Git%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/index.html property=og:url><meta content=Immortal-Fates property=og:site_name><meta content="Main Takeaway Git进阶（1）——了解Git是什么，Git的配置和所有 Git 基本的本地操作 希望通过Git - Book (git-scm.com)+Learn Git Branching来进一步掌握Git Learn to love the command line. Leave the IDE behind." property=og:description><meta content=zh_CN property=og:locale><meta content=2023-08-09T16:09:47.000Z property=article:published_time><meta content=2023-08-17T05:36:53.978Z property=article:modified_time><meta content=Immortal-Fates property=article:author><meta content=CS property=article:tag><meta content=Git property=article:tag><meta content=summary name=twitter:card><link href=http://example.com/2023/08/10/Git%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Git进阶（1） | Immortal-Fates</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><body itemscope itemtype=http://schema.org/WebPage><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Immortal-Fates</h1> <span class=logo-line-after><i></i></span> </a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-schedule"><a href=/schedule/ rel=section><i class="fa fa-calendar fa-fw"></i>日程表</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div id=search-result><div id=no-result><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class=back-to-top><i class="fa fa-arrow-up"></i><span>0%</span></div><a aria-label="Follow me on GitHub" title="Follow me on GitHub" class=github-corner href=https://github.com/Immortal-Fates rel=noopener target=_blank><svg viewbox="0 0 250 250" aria-hidden=true height=80 width=80><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" style="transform-origin: 130px 106px;" class=octo-arm fill=currentColor></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" class=octo-body fill=currentColor></path></svg></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=http://example.com/2023/08/10/Git%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/kuang.jpg itemprop=image> <meta content=Immortal-Fates itemprop=name> <meta content=愿你生命中有更多的云翳，来造就一个美丽的黄昏 itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=Immortal-Fates itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Git进阶（1）</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2023-08-10 00:09:47" datetime=2023-08-10T00:09:47+08:00>2023-08-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-17 13:36:53" datetime=2023-08-17T13:36:53+08:00 itemprop=dateModified>2023-08-17</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/CS/ itemprop=url rel=index><span itemprop=name>CS</span></a> </span> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span></div></header><div class=post-body itemprop=articleBody><h1 id=main-takeaway>Main Takeaway</h1><p>Git进阶（1）——了解Git是什么，Git的配置和所有 Git 基本的本地操作<p>希望通过<a href=https://git-scm.com/book/zh/v2 rel=noopener target=_blank>Git - Book (git-scm.com)</a>+<a href=https://learngitbranching.js.org/?locale=zh_CN rel=noopener target=_blank>Learn Git Branching</a>来进一步掌握Git<p><strong>Learn to love the command line. Leave the IDE behind.</strong></p><span id=more></span><h1 id=git是什么>Git是什么</h1><h2 id=git特点>Git特点</h2><ul><li><p>直接记录快照，而非差异比较： 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。<li><p>近乎所有操作都是本地执行，只有上传时才需联网<li><p>Git 保证完整性：Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。</p> <blockquote><p>Tips:Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</blockquote><li><p>Git 一般只添加数据：你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。</ul><h2 id=git三种状态>Git三种状态</h2><p>Git 有三种状态：<strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。<ul><li>已修改表示修改了文件，但还没保存到数据库中。<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。<li>已提交表示数据已经安全地保存在本地数据库中。</ul><p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。<figure><img alt=areas src=https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/areas.png><figcaption aria-hidden=true>areas</figcaption></figure><ul><li>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<li>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。<li>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</ul><h2 id=git工作流程>Git工作流程</h2><ol type=1><li>在工作区中修改文件。<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</ol><p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。<h2 id=git获取帮助>Git获取帮助</h2><p>Git命令的manpage<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>help</span> &LTverb></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git &LTverb> --<span class=built_in>help</span></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>man git-&LTverb></span></span><br></pre></table></figure><p>or 可以用 <code>-h</code> 选项获得更简明的 "help'':<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ git add -h </span><br></pre></table></figure><h1 id=git配置>Git配置</h1><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。<p>查看所有的配置以及它们所在的文件：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --list --show-origin</span></span><br></pre></table></figure><ul><li><h4 id=用户信息>用户信息</h4></ul><p>安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --global user.name <span class=string>"John Doe"</span></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --global user.email johndoe@example.com</span></span><br></pre></table></figure><blockquote><p>Tips:如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。（）</blockquote><ul><li><h4 id=文本编辑器>文本编辑器</h4> <p>既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器。</p> <p>如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --global core.editor emacs</span></span><br></pre></table></figure> <blockquote><p>在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。</blockquote><li><h4 id=检查配置信息>检查配置信息</h4> <p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p> <p>你可以通过输入 <code>git config &LTkey></code>： 来检查 Git 的某一项配置</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config user.name</span></span><br><span class=line>John Doe</span><br></pre></table></figure></ul><blockquote><p>Note： 由于 Git 会从多个文件中读取同一配置变量的不同值，因此你可能会在其中看到意料之外的值而不知道为什么。 此时，你可以查询 Git 中该变量的 <strong>原始</strong> 值，它会告诉你哪一个配置文件最后设置了该值：<code>$ git config --show-origin rerere.autoUpdate file:/home/johndoe/.gitconfig    false</code></blockquote><h1 id=git基础>Git基础</h1><h2 id=获取git-repository>获取Git repository</h2><p>通常有两种获取 Git 项目仓库的方式：<ul><li><p>将尚未进行版本控制的本地目录转换为 Git 仓库</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>cd /home/user/my_project</span><br><span class=line>git init</span><br></pre></table></figure> <p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p> <p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git add *.c</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git add LICENSE</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git commit -m <span class=string>'initial project version'</span></span></span><br></pre></table></figure><li><p>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</p> <p>克隆仓库的命令是 <code>git clone &LTurl></code></p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>clone</span> https://github.com/libgit2/libgit2</span></span><br></pre></table></figure> <p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。</p> <p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>clone</span> https://github.com/libgit2/libgit2 mylibgit</span></span><br></pre></table></figure></ul><h2 id=记录每次更新到仓库>记录每次更新到仓库</h2><p>每一个文件都有两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。（已跟踪的文件就是 Git 已经知道的文件。）<figure><img alt=lifecycle src=https://raw.githubusercontent.com/Immortal-Fates/figure_Bed/main/blog/lifecycle.png><figcaption aria-hidden=true>lifecycle</figcaption></figure><ul><li><h4 id=检查当前文件状态>检查当前文件状态</h4> <p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态<li><h4 id=状态简览>状态简览</h4> <p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git status -s</span></span><br><span class=line> M README</span><br><span class=line>MM Rakefile</span><br><span class=line>A  lib/git.rb</span><br><span class=line>M  lib/simplegit.rb</span><br><span class=line>?? LICENSE.txt</span><br></pre></table></figure> <p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。 <code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。<li><h4 id=跟踪新文件>跟踪新文件</h4> <p>使用命令 <code>git add</code> 开始跟踪一个文件，只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。<li><h4 id=暂存已修改的文件>暂存已修改的文件</h4> <p>文件出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</p> <blockquote><p>Tips:文件可能同时出现在暂存区（某一次修改被git add）和非暂存区(之后又修改了)。所以要重新git add</blockquote><li><h4 id=忽略文件>忽略文件</h4> <p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>touch .gitignore</span><br></pre></table></figure><li><p>文件 <code>.gitignore</code> 的格式规范如下：</p> <ul><li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<li>匹配模式可以以（<code>/</code>）开头防止递归。<li>匹配模式可以以（<code>/</code>）结尾指定目录。<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</ul> <p>所谓的 glob 模式是指 shell 所使用的简化了的<strong>正则表达式</strong>。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、 <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p> <blockquote><p>Tips：要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</blockquote><li><h4 id=查看已暂存和未暂存的修改>查看已暂存和未暂存的修改</h4> <p>想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 <code>git diff</code> 能通过文件补丁的格式更加具体地显示哪些行发生了改变。（ <code>--staged</code> 和 <code>--cached</code> 是同义词）</p> <ul><li>要查看修改之后还没有暂存起来的变化内容，不加参数直接输入 <code>git diff</code><li>要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异</ul> <blockquote><p>Tips：git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动</blockquote><li><h4 id=提交更新>提交更新</h4> <p>提交命令 <code>git commit</code>,这样会启动你选择的文本编辑器来输入提交说明。</p> <p>可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git commit -m <span class=string>"Story 182: Fix benchmarks for speed"</span></span></span><br></pre></table></figure> <blockquote><p>Note:更详细的内容修改提示可以用 <code>-v</code> 选项查看，这会将你所作的更改的 diff 输出呈现在编辑器中，以便让你知道本次提交具体作出哪些修改。</blockquote> <p>提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过<li><h4 id=跳过使用暂存区域>跳过使用暂存区域</h4> <p>只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git commit -a -m <span class=string>'added new benchmarks'</span></span></span><br></pre></table></figure><li><h4 id=移除文件>移除文件</h4> <p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p> <p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复</p> <p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>rm</span> --cached README</span></span><br></pre></table></figure> <blockquote><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到。</blockquote><li><h4 id=移动文件>移动文件</h4> <p>要在 Git 中对文件改名，可以这么做：（Git足够聪明）</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>mv</span> file_from file_to</span></span><br></pre></table></figure> <p>运行 <code>git mv</code> 就相当于运行了下面三条命令：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>mv</span> README.md README</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>rm</span> README.md</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git add README</span></span><br></pre></table></figure> <p>直接使用 <code>git mv</code> 方便得多。 不过在使用其他工具重命名文件时，记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</ul><h2 id=查看提交历史>查看提交历史</h2><p>完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<p>默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。<h3 id=常用的选项>常用的选项</h3><p><code>git log</code> 的常用选项:<table><colgroup><col style="width: 22%"><col style="width: 77%"></colgroup><thead><tr class=header><th style="text-align: left;">选项<th style="text-align: left;">说明<tbody><tr class=odd><td style="text-align: left;"><code>-p</code><td style="text-align: left;">按补丁格式显示每个提交引入的差异。<tr class=even><td style="text-align: left;"><code>--stat</code><td style="text-align: left;">显示每次提交的文件修改统计信息。<tr class=odd><td style="text-align: left;"><code>--shortstat</code><td style="text-align: left;">只显示 --stat 中最后的行数修改添加移除统计。<tr class=even><td style="text-align: left;"><code>--name-only</code><td style="text-align: left;">仅在提交信息后显示已修改的文件清单。<tr class=odd><td style="text-align: left;"><code>--name-status</code><td style="text-align: left;">显示新增、修改、删除的文件清单。<tr class=even><td style="text-align: left;"><code>--abbrev-commit</code><td style="text-align: left;">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。<tr class=odd><td style="text-align: left;"><code>--relative-date</code><td style="text-align: left;">使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。<tr class=even><td style="text-align: left;"><code>--graph</code><td style="text-align: left;">在日志旁以 ASCII 图形显示分支与合并历史。<tr class=odd><td style="text-align: left;"><code>--pretty</code><td style="text-align: left;">使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。<tr class=even><td style="text-align: left;"><code>--oneline</code><td style="text-align: left;"><code>--pretty=oneline --abbrev-commit</code> 合用的简写。</table><ul><li><p>其中一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交<li><p>想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项。在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结<li><p><code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。<code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一 。</p> <p><code>git log --pretty=format</code> <code>format</code> 接受的常用格式占位符的写法及其代表的意义（可以定制记录的显示格式）：</ul><table><thead><tr class=header><th style="text-align: left;">选项<th style="text-align: left;">说明<tbody><tr class=odd><td style="text-align: left;"><code>%H</code><td style="text-align: left;">提交的完整哈希值<tr class=even><td style="text-align: left;"><code>%h</code><td style="text-align: left;">提交的简写哈希值<tr class=odd><td style="text-align: left;"><code>%T</code><td style="text-align: left;">树的完整哈希值<tr class=even><td style="text-align: left;"><code>%t</code><td style="text-align: left;">树的简写哈希值<tr class=odd><td style="text-align: left;"><code>%P</code><td style="text-align: left;">父提交的完整哈希值<tr class=even><td style="text-align: left;"><code>%p</code><td style="text-align: left;">父提交的简写哈希值<tr class=odd><td style="text-align: left;"><code>%an</code><td style="text-align: left;">作者名字<tr class=even><td style="text-align: left;"><code>%ae</code><td style="text-align: left;">作者的电子邮件地址<tr class=odd><td style="text-align: left;"><code>%ad</code><td style="text-align: left;">作者修订日期（可以用 --date=选项 来定制格式）<tr class=even><td style="text-align: left;"><code>%ar</code><td style="text-align: left;">作者修订日期，按多久以前的方式显示<tr class=odd><td style="text-align: left;"><code>%cn</code><td style="text-align: left;">提交者的名字<tr class=even><td style="text-align: left;"><code>%ce</code><td style="text-align: left;">提交者的电子邮件地址<tr class=odd><td style="text-align: left;"><code>%cd</code><td style="text-align: left;">提交日期<tr class=even><td style="text-align: left;"><code>%cr</code><td style="text-align: left;">提交日期（距今多长时间）<tr class=odd><td style="text-align: left;"><code>%s</code><td style="text-align: left;">提交说明</table><p><strong>eg:</strong><p><figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>log</span> --pretty=format:<span class=string>"%h - %an, %ar : %s"</span></span></span><br><span class=line>ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class=line>085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class=line>a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></table></figure><ul><li>当 <code>oneline</code> 或 <code>format</code> 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。<code>--graph</code>可视化显示分支、合并历史</ul><h3 id=限制输出长度>限制输出长度</h3><ul><li><p>你可以使用类似 <code>-&LTn></code> 的选项，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的 <code>n</code> 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。<li><p><code>--since</code>==<code>--after</code>(仅显示指定时间之后的提交)和 <code>--until</code> ==<code>--before</code>(仅显示指定时间之前的提交)这种按照时间作限制的选项很有用。 下面的命令会列出最近两周的所有提交：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>log</span> --since=2.weeks</span></span><br></pre></table></figure> <p>该命令可用的格式十分丰富——可以是类似 <code>"2008-01-15"</code> 的具体的某一天，也可以是类似 <code>"2 years 1 day 3 minutes ago"</code> 的相对日期。<li><p>过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。</p> <blockquote><p>Tips:你可以指定多个 <code>--author</code> 和 <code>--grep</code> 搜索条件，这样会只输出匹配 <strong>任意</strong> <code>--author</code> 模式和 <strong>任意</strong> <code>--grep</code> 模式的提交。然而，如果你添加了 <code>--all-match</code> 选项， 则只会输出匹配 <strong>所有</strong> <code>--grep</code> 模式的提交。</blockquote><li><p>另一个非常有用的过滤器是 <code>-S</code>,它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p> <figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>log</span> -S function_name</span></span><br></pre></table></figure><li><p>隐藏合并提交</p> <p>按照你代码仓库的工作流程，记录中可能有为数不少的合并提交，它们所包含的信息通常并不多。 为了避免显示的合并提交弄乱历史记录，可以为 <code>log</code> 加上 <code>--no-merges</code> 选项。</ul><h2 id=撤销操作>撤销操作</h2><p>撤销操作是非常有用的，但<strong>有些撤消操作是不可逆的</strong><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。<p>Git 把 main 分支移回到 <code>C1</code>；现在我们的本地代码库根本就不知道有 <code>C2</code> 这个提交了。<blockquote><p>（译者注：在reset后， <code>C2</code> 所做的变更还在，但是处于未加入暂存区状态。）</blockquote><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的！<p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code><p>我们要撤销的提交记录后面多了一个新提交！这是因为新提交记录 <code>C2'</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2'</code> 的状态与 <code>C1</code> 是相同的。<p>revert 之后就可以把你的更改推送到远程仓库与别人分享<p>本地分支撤销用：<code>git reset + <想要回溯的版本（之前的）></code><p>远程分支撤销用：<code>git revert +<当前想要改变的分支（当前的）></code><h3 id=提交错误>提交错误</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git commit --amend</span></span><br></pre></table></figure><blockquote><p>Tips:即用一个 <strong>新的提交</strong> 替换旧的提交</blockquote><h3 id=取消暂存的文件>取消暂存的文件</h3><p><code>git reset HEAD &LTfile>…</code> 来取消暂存<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git reset HEAD CONTRIBUTING.md</span></span><br></pre></table></figure><blockquote><p>Tips:<code>git reset</code> 是个危险的命令，如果加上了 <code>--hard</code> 选项则更是如此。</blockquote><h3 id=撤消对文件的修改>撤消对文件的修改</h3><p>并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git checkout -- CONTRIBUTING.md</span></span><br></pre></table></figure><blockquote><p>Tips:请务必记得 <code>git checkout — &LTfile></code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</blockquote><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，Git 分支](https://git-scm.com/book/zh/v2/ch00/ch03-git-branching) 介绍保存进度与分支，这通常是更好的做法。<p>记住，在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。<h2 id=远程仓库的使用>远程仓库的使用</h2><h3 id=查看远程仓库>查看远程仓库</h3><p>查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字。<p>可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL；远程仓库会全部列出来（可能不止一个，eg:和几个协作者合作）<h3 id=添加远程仓库>添加远程仓库</h3><p><code>git clone</code> 命令会自行添加远程仓库。<p>运行 <code>git remote add &LTshortname> &LTurl></code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote -v</span></span><br><span class=line>pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class=line>pb	https://github.com/paulboone/ticgit (push)</span><br></pre></table></figure><p>可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ gir fetch pb</span><br></pre></table></figure><h3 id=从远程仓库中抓取与拉取>从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git fetch &LTremote></span></span><br></pre></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<p><code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。<p>如果你的当前分支设置了跟踪远程分支,可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。<h3 id=推送到远程仓库>推送到远程仓库</h3><p><code>git push &LTremote> &LTbranch></code><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。<h3 id=查看某个远程仓库>查看某个远程仓库</h3><p>想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &LTremote></code> 命令<p>它同样会列出远程仓库的 URL 与跟踪分支的信息(important)<h3 id=远程仓库的重命名与移除>远程仓库的重命名与移除</h3><p>可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote rename pb paul</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote</span></span><br><span class=line>paul</span><br></pre></table></figure><p>这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。(nice)<p>如果因为一些原因想要移除一个远程仓库（你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了）以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote remove paul</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git remote</span></span><br><span class=line></span><br></pre></table></figure><p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。<h2 id=打标签>打标签</h2><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ <code>v1.0</code> 、 <code>v2.0</code> 等等）<h3 id=列出标签>列出标签</h3><p>列出标签：<code>git tag</code> （可带上可选的 <code>-l</code> 选项 <code>--list</code>）（这个命令以字母顺序列出标签）：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag</span></span><br><span class=line>v1.0</span><br><span class=line>v2.0</span><br></pre></table></figure><p>你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag -l <span class=string>"v1.8.5*"</span></span></span><br><span class=line>v1.8.5</span><br><span class=line>v1.8.5-rc0</span><br></pre></table></figure><blockquote><p>Tips: 按照通配符列出标签需要 <code>-l</code> 或 <code>--list</code> 选项如果你只想要完整的标签列表，那么运行 <code>git tag</code> 就会默认假定你想要一个列表，它会直接给你列出来， 此时的 <code>-l</code> 或 <code>--list</code> 是可选的。然而，如果你提供了一个匹配标签名的通配模式，那么 <code>-l</code> 或 <code>--list</code> 就是强制使用的。</blockquote><h3 id=创建标签>创建标签</h3><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。<ul><li><p>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>git tag v1.0 c1</span><br></pre></table></figure><li><p>附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</ul><h4 id=轻量标签>轻量标签</h4><p>一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag v1.2-lw</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag</span></span><br><span class=line>v0.1</span><br><span class=line>v1.2</span><br><span class=line>v1.2-1w</span><br></pre></table></figure><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息。<h4 id=附注标签>附注标签</h4><p>创建附注标签: 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag -a v1.4 -m <span class=string>"my version 1.4"</span></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag</span></span><br><span class=line>v0.1</span><br><span class=line>v1.3</span><br><span class=line>v1.4</span><br></pre></table></figure><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。<p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息.<h3 id=后期打标签>后期打标签</h3><p>你也可以对过去的提交打标签。 假设提交历史是这样的：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git <span class=built_in>log</span> --pretty=oneline</span></span><br><span class=line>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class=line>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class=line>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></table></figure><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag -a v1.2 9fceb02</span></span><br></pre></table></figure><h3 id=共享标签>共享标签</h3><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin &LTtagname></code>。<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push origin v1.5</span></span><br></pre></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push origin --tags</span></span><br></pre></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。<blockquote><p>Tips: <code>git push</code> 推送两种标签使用 <code>git push &LTremote> --tags</code> 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</blockquote><h3 id=删除标签>删除标签</h3><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &LTtagname></code>。 例如，可以使用以下命令删除一个轻量标签：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git tag -d v1.4-lw</span></span><br><span class=line>Deleted tag 'v1.4-lw' (was e7d5add)</span><br></pre></table></figure><p>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 <code>git push &LTremote> :refs/tags/&LTtagname></code> 来更新你的远程仓库：<p>第一种变体是 <code>git push &LTremote> :refs/tags/&LTtagname></code> ：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push origin :refs/tags/v1.4-lw</span></span><br><span class=line>To /git@github.com:schacon/simplegit.git</span><br><span class=line> - [deleted]         v1.4-lw</span><br></pre></table></figure><p>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。<p>第二种<strong>更直观</strong>的删除远程标签的方式是：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push origin --delete &LTtagname></span></span><br></pre></table></figure><h3 id=检出标签>检出标签</h3><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git checkout 2.0.0</span></span><br></pre></table></figure><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git checkout -b version2 v2.0.0</span></span><br><span class=line>Switched to a new branch 'version2'</span><br></pre></table></figure><p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。<h3 id=git-describe>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>git describe &LTref></span><br></pre></table></figure><p><code>&LTref></code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（<code>HEAD</code>）。<p>它输出的结果是这样的：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTtag>_&LTnumCommits>_g&LThash></span><br></pre></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称<h2 id=git别名>Git别名</h2><p>配置Git command，看你需要咯<figure class="highlight console"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --global alias.co checkout</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git config --global alias.br branch</span></span><br></pre></table></figure><h1 id=references>References</h1><ul><li><a href=https://git-scm.com/book/zh/v2 rel=noopener target=_blank>Git - Book (git-scm.com)</a><li><a href=https://learngitbranching.js.org/?locale=zh_CN rel=noopener target=_blank>Learn Git Branching</a></ul></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Immortal-Fates<li class=post-copyright-link><strong>本文链接：</strong> <a href=http://example.com/2023/08/10/Git%E8%BF%9B%E9%98%B6%EF%BC%881%EF%BC%89/ title=Git进阶（1）>http://example.com/2023/08/10/Git进阶（1）/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/CS/ rel=tag># CS</a><a href=/tags/Git/ rel=tag># Git</a></div><div class=post-nav><div class=post-nav-item><a href=/2023/08/09/Markdown-in-Typora/ rel=prev title=Markdown_in_Typora> <i class="fa fa-chevron-left"></i> Markdown_in_Typora </a></div><div class=post-nav-item><a href=/2023/08/10/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/ rel=next title=桌面美化> 桌面美化 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#main-takeaway><span class=nav-number>1.</span> <span class=nav-text>Main Takeaway</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#git%E6%98%AF%E4%BB%80%E4%B9%88><span class=nav-number>2.</span> <span class=nav-text>Git是什么</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#git%E7%89%B9%E7%82%B9><span class=nav-number>2.1.</span> <span class=nav-text>Git特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#git%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81><span class=nav-number>2.2.</span> <span class=nav-text>Git三种状态</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B><span class=nav-number>2.3.</span> <span class=nav-text>Git工作流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#git%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9><span class=nav-number>2.4.</span> <span class=nav-text>Git获取帮助</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#git%E9%85%8D%E7%BD%AE><span class=nav-number>3.</span> <span class=nav-text>Git配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF><span class=nav-number>3.0.0.1.</span> <span class=nav-text>用户信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8><span class=nav-number>3.0.0.2.</span> <span class=nav-text>文本编辑器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A3%80%E6%9F%A5%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF><span class=nav-number>3.0.0.3.</span> <span class=nav-text>检查配置信息</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#git%E5%9F%BA%E7%A1%80><span class=nav-number>4.</span> <span class=nav-text>Git基础</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%8E%B7%E5%8F%96git-repository><span class=nav-number>4.1.</span> <span class=nav-text>获取Git repository</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93><span class=nav-number>4.2.</span> <span class=nav-text>记录每次更新到仓库</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81><span class=nav-number>4.2.0.1.</span> <span class=nav-text>检查当前文件状态</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%8A%B6%E6%80%81%E7%AE%80%E8%A7%88><span class=nav-number>4.2.0.2.</span> <span class=nav-text>状态简览</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%9F%E8%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6><span class=nav-number>4.2.0.3.</span> <span class=nav-text>跟踪新文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9A%82%E5%AD%98%E5%B7%B2%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6><span class=nav-number>4.2.0.4.</span> <span class=nav-text>暂存已修改的文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6><span class=nav-number>4.2.0.5.</span> <span class=nav-text>忽略文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E5%92%8C%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E4%BF%AE%E6%94%B9><span class=nav-number>4.2.0.6.</span> <span class=nav-text>查看已暂存和未暂存的修改</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0><span class=nav-number>4.2.0.7.</span> <span class=nav-text>提交更新</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F><span class=nav-number>4.2.0.8.</span> <span class=nav-text>跳过使用暂存区域</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6><span class=nav-number>4.2.0.9.</span> <span class=nav-text>移除文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6><span class=nav-number>4.2.0.10.</span> <span class=nav-text>移动文件</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2><span class=nav-number>4.3.</span> <span class=nav-text>查看提交历史</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%89%E9%A1%B9><span class=nav-number>4.3.1.</span> <span class=nav-text>常用的选项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%99%90%E5%88%B6%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6><span class=nav-number>4.3.2.</span> <span class=nav-text>限制输出长度</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C><span class=nav-number>4.4.</span> <span class=nav-text>撤销操作</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF><span class=nav-number>4.4.1.</span> <span class=nav-text>提交错误</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%96%E6%B6%88%E6%9A%82%E5%AD%98%E7%9A%84%E6%96%87%E4%BB%B6><span class=nav-number>4.4.2.</span> <span class=nav-text>取消暂存的文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%92%A4%E6%B6%88%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9><span class=nav-number>4.4.3.</span> <span class=nav-text>撤消对文件的修改</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8><span class=nav-number>4.5.</span> <span class=nav-text>远程仓库的使用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93><span class=nav-number>4.5.1.</span> <span class=nav-text>查看远程仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93><span class=nav-number>4.5.2.</span> <span class=nav-text>添加远程仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%AD%E6%8A%93%E5%8F%96%E4%B8%8E%E6%8B%89%E5%8F%96><span class=nav-number>4.5.3.</span> <span class=nav-text>从远程仓库中抓取与拉取</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93><span class=nav-number>4.5.4.</span> <span class=nav-text>推送到远程仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93><span class=nav-number>4.5.5.</span> <span class=nav-text>查看某个远程仓库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8E%E7%A7%BB%E9%99%A4><span class=nav-number>4.5.6.</span> <span class=nav-text>远程仓库的重命名与移除</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%89%93%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.</span> <span class=nav-text>打标签</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%97%E5%87%BA%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.1.</span> <span class=nav-text>列出标签</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.2.</span> <span class=nav-text>创建标签</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%BD%BB%E9%87%8F%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.2.1.</span> <span class=nav-text>轻量标签</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%99%84%E6%B3%A8%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.2.2.</span> <span class=nav-text>附注标签</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%8E%E6%9C%9F%E6%89%93%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.3.</span> <span class=nav-text>后期打标签</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%B1%E4%BA%AB%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.4.</span> <span class=nav-text>共享标签</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.5.</span> <span class=nav-text>删除标签</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE><span class=nav-number>4.6.6.</span> <span class=nav-text>检出标签</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#git-describe><span class=nav-number>4.6.7.</span> <span class=nav-text>Git Describe</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#git%E5%88%AB%E5%90%8D><span class=nav-number>4.7.</span> <span class=nav-text>Git别名</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#references><span class=nav-number>5.</span> <span class=nav-text>References</span></a></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Immortal-Fates class=site-author-image itemprop=image src=/images/kuang.jpg><p class=site-author-name itemprop=name>Immortal-Fates<div class=site-description itemprop=description>愿你生命中有更多的云翳，来造就一个美丽的黄昏</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>41</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>7</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>13</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2023</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Immortal-Fates</span></div><div class=powered-by><!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 --></div><script async src=http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><span class=post-meta-divider>|</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});</script><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script color=0,0,255 count=99 opacity=0.5 src=/lib/canvas-nest/canvas-nest.min.js zindex=-1></script><script src=/lib/anime.min.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/local-search.js></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script>